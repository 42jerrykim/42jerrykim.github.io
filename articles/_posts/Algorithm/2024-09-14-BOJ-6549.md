---
title: "[Algorithm] C++ 백준 6549번 : 히스토그램에서 가장 큰 직사각형"
categories: Algorithm
tags:
- Stack
- Histogram
- Data Structures 
header:
  teaser: /assets/images/undefined/algorithm.png
---

이번 포스팅에서는 백준 온라인 저지의 **6549번 문제 - 히스토그램에서 가장 큰 직사각형**을 다루겠다. 이 문제는 스택을 활용하여 효율적으로 해결할 수 있는 알고리즘 문제로, 코딩 테스트에서 자주 등장하는 유형이다.

[https://www.acmicpc.net/problem/6549]{https://www.acmicpc.net/problem/6549}

|![](/assets/images/undefined/algorithm.png)|
|:---:|
||

## 문제 설명

주어진 히스토그램에서 가장 큰 면적의 직사각형을 찾는 문제이다. 히스토그램은 너비가 1인 직사각형들이 연속해서 배열된 형태이며, 각 직사각형의 높이가 주어진다.

**입력**:

- 여러 개의 테스트 케이스로 구성되어 있다.
- 각 테스트 케이스는 첫 번째 숫자로 히스토그램을 구성하는 직사각형의 수 `N`이 주어지며, 이어서 `N`개의 직사각형의 높이가 주어진다.
- 입력의 마지막 줄에는 `0`이 주어진다.

**출력**:

- 각 테스트 케이스마다 가장 큰 직사각형의 면적을 출력한다.

## 문제 접근 방법

이 문제는 스택을 이용하여 시간 복잡도 O(N)으로 해결할 수 있다. 각 막대가 확장될 수 있는 최대 범위를 계산하여 최대 면적을 찾는 것이 핵심이다.

**주요 아이디어**

- **스택 활용**: 히스토그램의 막대 인덱스를 저장하는 스택을 사용한다.
- **높이 비교**: 현재 막대의 높이와 스택의 최상단에 있는 막대의 높이를 비교한다.
  - 현재 막대의 높이가 더 크거나 같으면 스택에 인덱스를 추가한다.
  - 현재 막대의 높이가 더 작으면 스택에서 막대를 꺼내며 면적을 계산한다.
- **면적 계산**: 스택에서 꺼낸 막대의 높이를 사용하여 가능한 최대 면적을 계산한다.

## 코드 구현

STL을 사용하지 않고 C++로 구현한 코드는 다음과 같다.

```cpp
#include <cstdio>

#define MAX_N 100000

int N;
int h[MAX_N + 2];     // 히스토그램의 높이 배열 (양쪽에 센티넬 추가)
int stack[MAX_N + 2]; // 인덱스를 저장하는 스택 배열
int top;              // 스택의 최상단 위치

int main() {
    while (true) {
        if (scanf("%d", &N) != 1 || N == 0)
            break; // 입력의 끝 또는 N이 0이면 종료
        for (int i = 1; i <= N; ++i) {
            scanf("%d", &h[i]); // 히스토그램 높이 입력
        }
        h[0] = 0;          // 시작에 높이 0인 센티넬 추가
        h[N + 1] = 0;      // 끝에 높이 0인 센티넬 추가

        top = 0;
        long long max_area = 0; // 최대 면적 저장 변수

        stack[top++] = 0;  // 스택 초기화 (센티넬 인덱스 추가)

        for (int i = 1; i <= N + 1; ++i) {
            // 현재 막대의 높이가 스택 최상단 막대의 높이보다 작을 때
            while (top > 0 && h[stack[top - 1]] > h[i]) {
                int height = h[stack[--top]]; // 스택에서 막대 인덱스 꺼내기
                int width = i - stack[top - 1] - 1; // 너비 계산
                long long area = (long long)height * width; // 면적 계산
                if (area > max_area)
                    max_area = area; // 최대 면적 갱신
            }
            stack[top++] = i; // 현재 인덱스를 스택에 추가
        }
        printf("%lld\n", max_area); // 결과 출력
    }
    return 0;
}
```

## 코드 설명

**1. 센티넬 추가**

- **시작과 끝에 높이가 0인 막대 추가**: 배열의 `0`번과 `N+1`번 인덱스에 높이 `0`을 추가한다. 이는 알고리즘을 단순화하고, 스택이 비어 있는지 확인하는 추가 작업을 줄여준다.

**2. 스택 초기화**

- 스택에는 막대의 인덱스를 저장한다.
- 초기에는 시작 센티넬의 인덱스 `0`을 스택에 넣는다.

**3. 히스토그램 순회**

- 인덱스 `i`를 `1`부터 `N+1`까지 순회한다.
- **현재 막대의 높이 `h[i]`가 스택의 최상단 막대 높이보다 크거나 같으면**:
  - 현재 인덱스 `i`를 스택에 추가한다.
- **현재 막대의 높이가 더 작으면**:
  - 스택에서 막대를 꺼내면서 면적을 계산한다.

**4. 면적 계산**

- 스택에서 막대를 꺼낼 때마다 다음을 수행한다:
  - **높이(`height`)**: 꺼낸 막대의 높이.
  - **너비(`width`)**: `i - stack[top - 1] - 1`.
    - `i`: 현재 인덱스.
    - `stack[top - 1]`: 스택의 새로운 최상단에 있는 인덱스.
  - **면적(`area`)**: `height * width`.
- 계산된 면적이 현재 최대 면적보다 크면 최대 면적을 갱신한다.

## 예시를 통한 이해

히스토그램 높이가 `[2, 1, 5, 6, 2, 3]`인 경우를 살펴보겠다.

1. 센티넬을 추가하여 높이 배열은 `[0, 2, 1, 5, 6, 2, 3, 0]`이 된다.
2. 스택에는 `[0]`이 초기값으로 들어간다.
3. 인덱스 `1`부터 `7`까지 순회하면서 다음을 수행한다:
   - 현재 막대의 높이가 스택 최상단 막대의 높이보다 크거나 같으면 인덱스를 스택에 추가한다.
   - 그렇지 않으면 스택에서 막대를 꺼내며 면적을 계산한다.
4. 이 과정을 통해 최대 면적인 `10`을 찾을 수 있다.

## 결론

이 문제는 스택을 활용하여 히스토그램에서 가장 큰 직사각형을 찾는 효율적인 방법을 학습할 수 있는 좋은 예제이다. 이러한 스택 기반의 알고리즘은 시간 복잡도를 O(N)으로 유지하면서도 최적의 해를 찾을 수 있게 해준다.
