---
title: "[DataStructure] 쿼드 트리(Quad Tree) 개념 정리"
categories: datastructure
tags:
- quadtree
- data structure
- spatial data
- image processing
- compression
- algorithm
- computer graphics
- terrain
- spatial partitioning
- path planning
- collision detection
- hierarchical data
- raster graphics
- data compression
- point quadtree
- region quadtree
- octree
- binary tree
- spatial indexing
- data retrieval
- recursive subdivision
- grid mapping
- mesh generation
- connected components
- adjacency
- bounding box
- dynamic environment
- efficient searching
- data representation
- computer vision
- robotics
- environmental mapping
- data organization
- spatial analysis
- geographic information systems
- 2D graphics
- game development
- performance optimization
- data structures and algorithms
- hierarchical structures
- data visualization
- point location
- insertion and deletion
- tree traversal
- data management
- algorithm efficiency
- computational geometry
- data representation techniques
- spatial queries
header:
teaser: /assets/images/undefined/teaser.jpg
---

쿼드 트리는 2차원 공간을 4개의 동일한 구역으로 재귀적으로 세분화하여 분할하는 트리 구조의 데이터이다. 이 구조는 데이터베이스 검색, 이미지 처리, 지형 데이터 관리 등 다양한 분야에서 활용된다. 쿼드 트리는 각 내부 노드가 4개의 자식 노드를 가지며, 이를 통해 공간을 효율적으로 분할하고 검색할 수 있는 장점을 가진다. 예를 들어, 넓은 지역에 대한 데이터베이스 구축에 매우 용이하며, 특히 지형과 같은 복잡한 데이터 구조를 다룰 때 유용하다. 쿼드 트리는 또한 충돌 감지와 같은 게임 개발에서도 중요한 역할을 하며, 객체 간의 관계를 효율적으로 관리할 수 있도록 돕는다. 이처럼 쿼드 트리는 다양한 응용 프로그램에서 공간 데이터를 효과적으로 처리하고 관리하는 데 필수적인 데이터 구조로 자리 잡고 있다.


|![]()|
|:---:|
||


<!--
##### Outline #####
-->

<!--
---
## 쿼드 트리(Quad Tree) 개요
**쿼드 트리의 정의**  
**쿼드 트리의 구조**  
**쿼드 트리의 특징**  
**쿼드 트리의 활용 분야**  

## 쿼드 트리의 동작 원리
**공간 분할의 원리**  
**노드의 삽입 과정**  
**노드의 삭제 과정**  
**쿼드 트리의 탐색 과정**  

## 쿼드 트리의 종류
**영역 쿼드 트리(Region Quadtree)**  
**점 쿼드 트리(Point Quadtree)**  
**PR 쿼드 트리(Point-Region Quadtree)**  
**압축 쿼드 트리(Compressed Quadtree)**  

## 쿼드 트리의 구현
**쿼드 트리의 기본 구조**  
**쿼드 트리 삽입 알고리즘**  
**쿼드 트리 삭제 알고리즘**  
**쿼드 트리 탐색 알고리즘**  

## 쿼드 트리의 응용
**이미지 처리에서의 쿼드 트리**  
**로봇 경로 계획에서의 쿼드 트리**  
**게임 개발에서의 쿼드 트리**  
**지형 데이터 처리에서의 쿼드 트리**  

## 실용적인 예제
**쿼드 트리 구현 예제**  
**쿼드 트리 활용 예제**  
**쿼드 트리 성능 비교**  
**쿼드 트리와 다른 데이터 구조 비교**  

## 자주 묻는 질문(FAQ)
**쿼드 트리의 장점은 무엇인가요?**  
**쿼드 트리의 단점은 무엇인가요?**  
**쿼드 트리와 다른 트리 구조의 차이점은 무엇인가요?**  
**쿼드 트리를 사용할 때 주의할 점은 무엇인가요?**  

## 관련 기술
**옥트리(Octree)**  
**이진 트리(Binary Tree)**  
**k-차원 트리(k-d Tree)**  
**R-트리(R-Tree)**  

## 결론
**쿼드 트리의 중요성 요약**  
**쿼드 트리의 미래 가능성**  
**쿼드 트리 학습의 필요성**  
**쿼드 트리 관련 자료 추천**  
---
-->

<!--
---
## 쿼드 트리(Quad Tree) 개요
**쿼드 트리의 정의**  
**쿼드 트리의 구조**  
**쿼드 트리의 특징**  
**쿼드 트리의 활용 분야**  
-->

## 쿼드 트리(Quad Tree) 개요

**쿼드 트리의 정의**  

쿼드 트리는 2차원 공간을 사분면으로 분할하여 데이터를 저장하는 트리 구조이다. 각 노드는 최대 4개의 자식 노드를 가질 수 있으며, 이는 공간을 네 개의 사분면으로 나누는 것을 의미한다. 쿼드 트리는 주로 이미지 처리, GIS(지리 정보 시스템), 게임 개발 등에서 사용된다.

**쿼드 트리의 구조**  

쿼드 트리는 루트 노드에서 시작하여 각 노드가 4개의 자식 노드를 가질 수 있는 구조로 되어 있다. 각 노드는 특정 영역을 나타내며, 자식 노드는 해당 영역을 더 세분화한 영역을 나타낸다. 이러한 구조는 공간을 효율적으로 관리하고 검색할 수 있게 해준다.

**쿼드 트리의 특징**  

쿼드 트리는 다음과 같은 특징을 가진다. 첫째, 공간을 효율적으로 분할하여 데이터의 검색 속도를 높인다. 둘째, 동적으로 공간을 분할할 수 있어 다양한 크기의 데이터를 처리할 수 있다. 셋째, 각 노드가 자식 노드를 가질 수 있는 구조로 인해 복잡한 공간 데이터를 효과적으로 표현할 수 있다.

**쿼드 트리의 활용 분야**  

쿼드 트리는 여러 분야에서 활용된다. 예를 들어, 이미지 처리에서는 이미지를 사분면으로 나누어 각 영역의 색상 정보를 저장할 수 있다. GIS에서는 지리적 데이터를 효율적으로 관리하고 검색하는 데 사용된다. 게임 개발에서는 충돌 감지 및 경로 탐색에 유용하다. 이러한 다양한 활용 분야 덕분에 쿼드 트리는 매우 중요한 데이터 구조로 자리 잡고 있다.

<!--
## 쿼드 트리의 동작 원리
**공간 분할의 원리**  
**노드의 삽입 과정**  
**노드의 삭제 과정**  
**쿼드 트리의 탐색 과정**  
-->

## 쿼드 트리의 동작 원리

**공간 분할의 원리**  

쿼드 트리는 2차원 공간을 효율적으로 분할하기 위해 설계된 데이터 구조이다. 이 구조는 주어진 공간을 네 개의 사각형 영역으로 나누는 방식으로 작동한다. 각 사각형은 다시 네 개의 하위 사각형으로 나눌 수 있으며, 이러한 방식으로 계속해서 공간을 세분화할 수 있다. 이 과정은 특정 기준에 따라 반복되며, 주로 객체의 밀도나 분포에 따라 결정된다. 쿼드 트리는 이러한 공간 분할을 통해 데이터의 검색 및 삽입, 삭제를 효율적으로 수행할 수 있도록 돕는다.

**노드의 삽입 과정**  

쿼드 트리에 노드를 삽입하는 과정은 다음과 같다. 먼저, 삽입할 객체의 위치를 확인하고, 해당 위치가 포함된 사각형 영역을 찾는다. 그 후, 해당 영역이 이미 다른 객체로 채워져 있다면, 그 영역을 네 개의 하위 영역으로 분할한다. 이 과정을 반복하여 적절한 위치를 찾을 때까지 진행한다. 최종적으로, 빈 공간이 발견되면 새로운 노드를 해당 위치에 삽입한다. 이 과정은 객체의 수가 많아질수록 더욱 복잡해질 수 있지만, 쿼드 트리는 이러한 복잡성을 최소화하는 데 도움을 준다.

**노드의 삭제 과정**  

쿼드 트리에서 노드를 삭제하는 과정은 삽입 과정과는 다소 다르다. 삭제할 노드를 찾은 후, 해당 노드를 제거하고, 그 노드가 속한 영역이 더 이상 다른 노드로 채워져 있지 않다면, 그 영역을 부모 노드로 합칠 수 있다. 이 과정은 트리의 균형을 유지하는 데 중요하며, 불필요한 공간을 줄이는 데 기여한다. 그러나 삭제 후에도 여전히 다른 노드가 존재한다면, 해당 영역은 그대로 유지된다.

**쿼드 트리의 탐색 과정**  

쿼드 트리에서 특정 객체를 탐색하는 과정은 다음과 같다. 먼저, 탐색할 객체의 위치를 기반으로 해당 위치가 포함된 사각형 영역을 찾는다. 그 후, 해당 영역의 자식 노드들을 순차적으로 탐색하여 원하는 객체를 찾는다. 이 과정은 재귀적으로 진행되며, 객체가 존재하는 영역을 찾을 때까지 반복된다. 쿼드 트리는 이러한 탐색 과정을 통해 빠른 검색 속도를 제공하며, 대규모 데이터셋에서도 효율적으로 작동할 수 있다.

<!--
## 쿼드 트리의 종류
**영역 쿼드 트리(Region Quadtree)**  
**점 쿼드 트리(Point Quadtree)**  
**PR 쿼드 트리(Point-Region Quadtree)**  
**압축 쿼드 트리(Compressed Quadtree)**  
-->

## 쿼드 트리의 종류

**영역 쿼드 트리(Region Quadtree)**  

영역 쿼드 트리는 2차원 공간을 네 개의 사각형 영역으로 분할하여 데이터를 저장하는 구조이다. 각 노드는 사각형 영역을 나타내며, 자식 노드는 해당 영역을 다시 네 개의 하위 영역으로 나눈다. 이 방식은 공간을 효율적으로 관리할 수 있게 해주며, 주로 이미지 처리나 GIS(지리 정보 시스템)에서 많이 사용된다. 영역 쿼드 트리는 공간의 밀도가 낮은 지역에서는 큰 영역을 사용하고, 밀도가 높은 지역에서는 더 작은 영역으로 세분화하여 데이터를 저장한다.

**점 쿼드 트리(Point Quadtree)**  

점 쿼드 트리는 주로 점 데이터(예: 좌표)를 저장하기 위해 설계된 쿼드 트리이다. 각 노드는 하나의 점을 저장하며, 해당 점이 위치한 사각형 영역에 따라 자식 노드로 분할된다. 점 쿼드 트리는 주로 공간 검색, 근접 검색, 그리고 충돌 감지와 같은 작업에 유용하다. 이 구조는 점들이 고르게 분포되어 있을 때 효율적이지만, 점들이 특정 지역에 집중되어 있을 경우 성능이 저하될 수 있다.

**PR 쿼드 트리(Point-Region Quadtree)**  

PR 쿼드 트리는 점 쿼드 트리와 영역 쿼드 트리의 장점을 결합한 구조이다. 이 구조에서는 각 노드가 점과 영역을 모두 저장할 수 있다. 즉, 노드는 특정 점을 포함하는 영역을 나타내며, 이 영역 내에 있는 점들을 자식 노드로 분할하여 저장한다. PR 쿼드 트리는 공간 데이터의 밀도가 불균형할 때 유용하며, 다양한 응용 분야에서 사용된다.

**압축 쿼드 트리(Compressed Quadtree)**  

압축 쿼드 트리는 쿼드 트리의 공간 효율성을 높이기 위해 설계된 구조이다. 일반적인 쿼드 트리는 비어 있는 노드가 많을 경우 메모리 낭비가 발생할 수 있다. 압축 쿼드 트리는 이러한 비어 있는 노드를 제거하고, 연속된 비어 있는 영역을 하나의 노드로 압축하여 저장한다. 이 방식은 메모리 사용량을 줄이고, 검색 성능을 향상시킬 수 있다. 압축 쿼드 트리는 대규모 데이터셋을 처리할 때 특히 유용하다.

<!--
## 쿼드 트리의 구현
**쿼드 트리의 기본 구조**  
**쿼드 트리 삽입 알고리즘**  
**쿼드 트리 삭제 알고리즘**  
**쿼드 트리 탐색 알고리즘**  
-->

## 쿼드 트리의 구현

**쿼드 트리의 기본 구조**  

쿼드 트리는 2차원 공간을 사분면으로 나누어 데이터를 저장하는 트리 구조이다. 각 노드는 최대 4개의 자식 노드를 가질 수 있으며, 각 자식 노드는 공간의 사분면을 나타낸다. 쿼드 트리는 다음과 같은 기본 구조를 가진다:

- **노드(Node)**: 각 노드는 특정 영역을 나타내며, 해당 영역에 포함된 데이터를 저장한다.
- **자식 노드(Child Nodes)**: 각 노드는 최대 4개의 자식 노드를 가질 수 있으며, 이들은 각각 북동(Northeast), 북서(Northwest), 남동(Southeast), 남서(Southwest) 사분면을 나타낸다.
- **리프 노드(Leaf Node)**: 더 이상 분할할 수 없는 노드로, 실제 데이터를 저장하는 노드이다.

쿼드 트리는 공간을 효율적으로 분할하여 데이터를 관리할 수 있는 장점이 있다.

**쿼드 트리 삽입 알고리즘**  

쿼드 트리에 데이터를 삽입하는 과정은 다음과 같다:

1. **기본 조건 확인**: 삽입할 데이터의 위치가 현재 노드의 영역에 포함되는지 확인한다.
2. **리프 노드인지 확인**: 현재 노드가 리프 노드인지 확인한다. 리프 노드라면 데이터를 저장하고 종료한다.
3. **자식 노드 생성**: 현재 노드가 리프 노드가 아니면, 자식 노드가 존재하는지 확인하고, 존재하지 않으면 자식 노드를 생성한다.
4. **재귀 호출**: 해당 데이터의 위치에 맞는 자식 노드로 재귀적으로 삽입 과정을 반복한다.

이러한 방식으로 쿼드 트리는 데이터를 효율적으로 삽입할 수 있다.

**쿼드 트리 삭제 알고리즘**  

쿼드 트리에서 데이터를 삭제하는 과정은 다음과 같다:

1. **기본 조건 확인**: 삭제할 데이터의 위치가 현재 노드의 영역에 포함되는지 확인한다.
2. **리프 노드인지 확인**: 현재 노드가 리프 노드라면 해당 데이터를 삭제하고 종료한다.
3. **자식 노드 탐색**: 현재 노드가 리프 노드가 아니면, 자식 노드로 이동하여 삭제할 데이터를 찾는다.
4. **노드 병합**: 삭제 후, 자식 노드가 모두 비어있다면 현재 노드를 병합하여 공간을 최적화한다.

이러한 방식으로 쿼드 트리는 데이터를 삭제할 수 있다.

**쿼드 트리 탐색 알고리즘**  

쿼드 트리에서 데이터를 탐색하는 과정은 다음과 같다:

1. **기본 조건 확인**: 탐색할 데이터의 위치가 현재 노드의 영역에 포함되는지 확인한다.
2. **리프 노드인지 확인**: 현재 노드가 리프 노드라면 해당 데이터를 반환하고 종료한다.
3. **자식 노드 탐색**: 현재 노드가 리프 노드가 아니면, 자식 노드로 이동하여 탐색을 계속한다.
4. **재귀 호출**: 해당 데이터의 위치에 맞는 자식 노드로 재귀적으로 탐색 과정을 반복한다.

이러한 방식으로 쿼드 트리는 데이터를 효율적으로 탐색할 수 있다.

<!--
## 쿼드 트리의 응용
**이미지 처리에서의 쿼드 트리**  
**로봇 경로 계획에서의 쿼드 트리**  
**게임 개발에서의 쿼드 트리**  
**지형 데이터 처리에서의 쿼드 트리**  
-->

## 쿼드 트리의 응용

**이미지 처리에서의 쿼드 트리**  

쿼드 트리는 이미지 처리 분야에서 매우 유용하게 사용된다. 이미지의 각 픽셀을 공간적으로 분할하여 저장할 수 있기 때문에, 특정 영역의 색상이나 밝기 정보를 효율적으로 관리할 수 있다. 예를 들어, 고해상도 이미지를 쿼드 트리로 분할하면, 비슷한 색상을 가진 픽셀들을 하나의 노드로 묶어 저장할 수 있다. 이를 통해 이미지 압축 및 검색 속도를 향상시킬 수 있다. 또한, 이미지의 특정 영역을 빠르게 탐색할 수 있어, 이미지 필터링이나 변환 작업을 수행할 때 유리하다.

**로봇 경로 계획에서의 쿼드 트리**  

로봇 경로 계획에서도 쿼드 트리는 중요한 역할을 한다. 로봇이 이동할 수 있는 공간을 쿼드 트리로 모델링하면, 장애물과 자유 공간을 효과적으로 구분할 수 있다. 이를 통해 로봇은 최적의 경로를 찾는 데 필요한 계산을 줄일 수 있다. 쿼드 트리를 사용하여 로봇의 위치와 주변 환경을 실시간으로 업데이트하면, 동적인 환경에서도 안정적인 경로 계획이 가능하다. 이러한 방식은 특히 자율주행차나 드론과 같은 이동체에서 많이 활용된다.

**게임 개발에서의 쿼드 트리**  

게임 개발에서도 쿼드 트리는 매우 유용하다. 게임의 맵을 쿼드 트리로 분할하면, 각 객체의 위치를 효율적으로 관리할 수 있다. 예를 들어, 게임에서 충돌 감지를 수행할 때, 쿼드 트리를 사용하면 특정 영역 내의 객체들만을 대상으로 검사를 수행할 수 있어 성능을 크게 향상시킬 수 있다. 또한, 쿼드 트리를 통해 시각적 요소를 최적화하여 렌더링 성능을 개선할 수 있다. 이러한 이유로 많은 게임 엔진에서 쿼드 트리를 기본적으로 지원하고 있다.

**지형 데이터 처리에서의 쿼드 트리**  

지형 데이터 처리에서도 쿼드 트리는 중요한 역할을 한다. 대규모 지형 데이터를 효율적으로 저장하고 관리하기 위해 쿼드 트리를 사용할 수 있다. 예를 들어, GIS(지리 정보 시스템)에서는 지형의 높이 정보나 지리적 특성을 쿼드 트리로 모델링하여, 특정 지역의 데이터를 빠르게 검색하고 분석할 수 있다. 또한, 쿼드 트리를 사용하면 지형의 세부 정보를 필요에 따라 동적으로 로드하거나 언로드할 수 있어 메모리 사용을 최적화할 수 있다. 이러한 방식은 특히 대규모 오픈 월드 게임이나 시뮬레이션에서 유용하다.

<!--
## 실용적인 예제
**쿼드 트리 구현 예제**  
**쿼드 트리 활용 예제**  
**쿼드 트리 성능 비교**  
**쿼드 트리와 다른 데이터 구조 비교**  
-->

## 실용적인 예제

**쿼드 트리 구현 예제**  

쿼드 트리를 구현하기 위해서는 먼저 기본적인 노드 구조를 정의해야 한다. 각 노드는 네 개의 자식 노드를 가질 수 있으며, 이 자식 노드는 각각 사각형 영역을 나타낸다. 아래는 파이썬으로 쿼드 트리를 구현하는 간단한 예제 코드이다.

```python
class QuadTreeNode:
    def __init__(self, x, y, width, height):
        self.boundary = (x, y, width, height)  # 노드의 경계
        self.children = [None, None, None, None]  # 자식 노드
        self.points = []  # 노드에 저장된 점들
        self.capacity = 4  # 노드가 가질 수 있는 최대 점의 수

    def insert(self, point):
        # 점이 현재 노드의 경계에 포함되는지 확인
        if not self.contains(point):
            return False
        
        # 현재 노드에 점을 추가
        if len(self.points) < self.capacity:
            self.points.append(point)
            return True
        
        # 자식 노드가 생성되지 않았다면 생성
        if self.children[0] is None:
            self.subdivide()
        
        # 자식 노드에 점을 삽입
        for child in self.children:
            if child.insert(point):
                return True
        
        return False

    def contains(self, point):
        x, y = point
        bx, by, bw, bh = self.boundary
        return bx <= x < bx + bw and by <= y < by + bh

    def subdivide(self):
        x, y, width, height = self.boundary
        half_width = width / 2
        half_height = height / 2
        self.children[0] = QuadTreeNode(x, y, half_width, half_height)  # NW
        self.children[1] = QuadTreeNode(x + half_width, y, half_width, half_height)  # NE
        self.children[2] = QuadTreeNode(x, y + half_height, half_width, half_height)  # SW
        self.children[3] = QuadTreeNode(x + half_width, y + half_height, half_width, half_height)  # SE
```

**쿼드 트리 활용 예제**  

쿼드 트리는 다양한 분야에서 활용될 수 있다. 예를 들어, 이미지 처리에서는 이미지를 작은 사각형으로 나누어 각 영역의 색상 정보를 저장하는 데 사용된다. 이를 통해 이미지의 특정 영역을 빠르게 검색하고 수정할 수 있다. 또한, 게임 개발에서는 게임 맵의 객체를 관리하는 데 유용하다. 쿼드 트리를 사용하면 특정 영역 내의 객체를 효율적으로 찾을 수 있어 성능을 크게 향상시킬 수 있다.

**쿼드 트리 성능 비교**  

쿼드 트리는 다른 데이터 구조와 비교했을 때 공간 분할에 매우 효율적이다. 예를 들어, 이진 트리와 비교했을 때, 쿼드 트리는 2차원 공간을 효과적으로 나누어 검색 성능을 향상시킨다. 쿼드 트리는 평균적으로 O(log n)의 시간 복잡도를 가지며, 이는 대규모 데이터셋에서도 빠른 검색을 가능하게 한다. 반면, 이진 트리는 1차원 데이터에 최적화되어 있어 2차원 데이터에 적용할 경우 성능이 저하될 수 있다.

**쿼드 트리와 다른 데이터 구조 비교**  

쿼드 트리는 R-트리, k-차원 트리(k-d Tree)와 같은 다른 공간 분할 데이터 구조와 비교할 수 있다. R-트리는 주로 다차원 데이터베이스에서 사용되며, 사각형 영역을 기반으로 하여 효율적인 검색을 지원한다. 반면, k-차원 트리는 k차원 공간에서 점을 저장하는 데 최적화되어 있다. 쿼드 트리는 2차원 공간에 특화되어 있어, 특정 상황에서는 다른 데이터 구조보다 더 나은 성능을 발휘할 수 있다. 각 데이터 구조의 특성과 장단점을 이해하고, 상황에 맞는 구조를 선택하는 것이 중요하다.

<!--
## 자주 묻는 질문(FAQ)
**쿼드 트리의 장점은 무엇인가요?**  
**쿼드 트리의 단점은 무엇인가요?**  
**쿼드 트리와 다른 트리 구조의 차이점은 무엇인가요?**  
**쿼드 트리를 사용할 때 주의할 점은 무엇인가요?**  
-->

## 자주 묻는 질문(FAQ)

**쿼드 트리의 장점은 무엇인가요?**  

쿼드 트리는 공간을 효율적으로 분할하여 데이터를 저장할 수 있는 구조이다. 이로 인해 대규모 데이터셋을 다룰 때 빠른 검색과 삽입, 삭제가 가능하다. 특히, 2차원 공간에서의 데이터 처리에 유리하며, 이미지 처리나 GIS(지리 정보 시스템)와 같은 분야에서 많이 사용된다. 또한, 쿼드 트리는 메모리 사용이 효율적이며, 특정 영역에 대한 쿼리를 빠르게 수행할 수 있는 장점이 있다.

**쿼드 트리의 단점은 무엇인가요?**  

쿼드 트리는 특정 상황에서 비효율적일 수 있다. 예를 들어, 데이터가 불균형하게 분포되어 있을 경우, 쿼드 트리의 깊이가 깊어져 탐색 속도가 느려질 수 있다. 또한, 동적으로 변화하는 데이터에 대해 자주 재구성이 필요할 수 있어, 이로 인해 성능 저하가 발생할 수 있다. 마지막으로, 쿼드 트리는 2차원 공간에 최적화되어 있어, 3차원 데이터 처리에는 적합하지 않다.

**쿼드 트리와 다른 트리 구조의 차이점은 무엇인가요?**  

쿼드 트리는 2차원 공간을 네 개의 사각형으로 나누는 반면, 이진 트리는 각 노드가 최대 두 개의 자식을 가지는 구조이다. k-차원 트리는 k차원 공간을 다루기 위해 설계된 트리 구조로, 쿼드 트리보다 더 일반적인 형태이다. R-트리는 다차원 데이터베이스에서 효율적인 검색을 위해 설계된 구조로, 쿼드 트리와는 다른 방식으로 공간을 분할한다. 이러한 차이점들은 각 데이터 구조가 특정 용도에 맞게 최적화되어 있다는 것을 의미한다.

**쿼드 트리를 사용할 때 주의할 점은 무엇인가요?**  

쿼드 트리를 사용할 때는 데이터의 분포를 고려해야 한다. 데이터가 고르게 분포되어 있지 않으면, 쿼드 트리의 성능이 저하될 수 있다. 또한, 동적 데이터에 대해 자주 업데이트가 필요한 경우, 쿼드 트리의 재구성이 필요할 수 있으므로, 이로 인한 성능 저하를 염두에 두어야 한다. 마지막으로, 쿼드 트리를 사용할 때는 메모리 사용량을 고려해야 하며, 필요에 따라 다른 데이터 구조와의 조합을 고려하는 것이 좋다.

<!--
## 관련 기술
**옥트리(Octree)**  
**이진 트리(Binary Tree)**  
**k-차원 트리(k-d Tree)**  
**R-트리(R-Tree)**  
-->

## 관련 기술

**옥트리(Octree)**  
옥트리는 3차원 공간을 분할하는 데이터 구조로, 각 노드가 최대 8개의 자식 노드를 가질 수 있다. 주로 3D 그래픽스와 게임 개발에서 사용되며, 공간을 효율적으로 관리하고 검색하는 데 유용하다. 옥트리는 쿼드 트리와 유사하지만, 3차원 공간을 다룬다는 점에서 차이가 있다. 

**이진 트리(Binary Tree)**  
이진 트리는 각 노드가 최대 2개의 자식 노드를 가지는 트리 구조이다. 이진 트리는 데이터 검색, 정렬 및 저장에 널리 사용되며, 이진 탐색 트리와 같은 다양한 변형이 존재한다. 쿼드 트리와 비교할 때, 이진 트리는 주로 1차원 데이터에 적합하다.

**k-차원 트리(k-d Tree)**  
k-차원 트리는 k차원 공간에서 데이터를 저장하는 데 사용되는 트리 구조이다. 주로 다차원 검색 문제를 해결하는 데 유용하며, 쿼드 트리와 유사하지만, k차원 공간을 다룬다는 점에서 차이가 있다. k-d 트리는 주로 범위 검색 및 근접 검색에 사용된다.

**R-트리(R-Tree)**  
R-트리는 다차원 데이터의 저장 및 검색을 위한 트리 구조로, 주로 공간 데이터베이스에서 사용된다. R-트리는 사각형 영역을 기반으로 하여 데이터를 그룹화하고, 효율적인 검색을 가능하게 한다. 쿼드 트리와 유사하지만, R-트리는 더 복잡한 형태의 공간 데이터를 처리하는 데 적합하다. 

이와 같은 다양한 데이터 구조들은 각각의 특성과 장단점이 있으며, 특정 문제에 따라 적절한 구조를 선택하는 것이 중요하다. 쿼드 트리는 2차원 공간을 다루는 데 최적화되어 있어, 특정 응용 분야에서 매우 유용하게 사용될 수 있다.

<!--
## 결론
**쿼드 트리의 중요성 요약**  
**쿼드 트리의 미래 가능성**  
**쿼드 트리 학습의 필요성**  
**쿼드 트리 관련 자료 추천**  
---
-->

## 결론

**쿼드 트리의 중요성 요약**  

쿼드 트리는 2차원 공간을 효율적으로 분할하고 관리하는 데이터 구조로, 다양한 분야에서 활용되고 있다. 특히, 이미지 처리, 로봇 경로 계획, 게임 개발 등에서 그 유용성이 두드러진다. 쿼드 트리는 공간을 네 개의 사분면으로 나누어 데이터를 저장하므로, 특정 영역에 대한 탐색과 삽입, 삭제가 빠르게 이루어질 수 있다. 이러한 특성 덕분에 쿼드 트리는 대규모 데이터 처리에 적합한 구조로 자리 잡고 있다.

**쿼드 트리의 미래 가능성**  

앞으로 쿼드 트리는 더욱 발전할 가능성이 크다. 특히, 인공지능과 머신러닝의 발전에 따라 대량의 데이터 처리와 분석이 필요해짐에 따라 쿼드 트리의 중요성이 더욱 부각될 것이다. 또한, 자율주행차와 같은 최신 기술에서도 쿼드 트리를 활용한 경로 계획 및 환경 인식이 이루어질 것으로 예상된다. 이러한 기술들은 쿼드 트리의 효율성을 더욱 높일 수 있는 기회를 제공할 것이다.

**쿼드 트리 학습의 필요성**  

쿼드 트리는 데이터 구조와 알고리즘을 배우는 데 있어 중요한 주제 중 하나이다. 특히, 공간 데이터 처리에 대한 이해를 높이는 데 큰 도움이 된다. 쿼드 트리를 학습함으로써, 학생들은 데이터 구조의 기본 개념을 이해하고, 실제 문제를 해결하는 데 필요한 기술을 습득할 수 있다. 또한, 쿼드 트리는 다른 데이터 구조와의 비교를 통해 더 깊이 있는 이해를 제공한다.

**쿼드 트리 관련 자료 추천**  

쿼드 트리를 학습하기 위해서는 다양한 자료를 참고하는 것이 좋다. 다음은 추천할 만한 자료들이다:

1. **서적**: "Data Structures and Algorithms"와 같은 기본 서적에서 쿼드 트리에 대한 장을 찾아보는 것이 좋다.
2. **온라인 강의**: Coursera, edX와 같은 플랫폼에서 제공하는 데이터 구조 관련 강의를 수강하는 것도 유익하다.
3. **오픈 소스 프로젝트**: GitHub에서 쿼드 트리 관련 프로젝트를 찾아보고, 실제 구현을 통해 학습하는 것도 좋은 방법이다.
4. **논문**: 최신 연구 결과를 통해 쿼드 트리의 발전 방향과 응용 사례를 살펴보는 것도 도움이 된다.

쿼드 트리는 그 자체로도 흥미로운 주제이며, 다양한 분야에서의 응용 가능성 덕분에 앞으로도 많은 연구와 개발이 이루어질 것이다. 쿼드 트리를 통해 데이터 구조의 세계를 탐험해보는 것은 매우 가치 있는 경험이 될 것이다.

<!--
##### Reference #####
-->

## Reference


* [https://velog.io/@youngjun_10/쿼드-트리Quad-Tree](https://velog.io/@youngjun_10/쿼드-트리Quad-Tree)
* [https://hyo-ue4study.tistory.com/235](https://hyo-ue4study.tistory.com/235)
* [https://velog.io/@jk01019/Quadtree](https://velog.io/@jk01019/Quadtree)
* [https://en.wikipedia.org/wiki/Quadtree](https://en.wikipedia.org/wiki/Quadtree)
* [https://joonyle99.github.io/datastructure_algorithm/DataStructure_Algorithm-Quadtree/](https://joonyle99.github.io/datastructure_algorithm/DataStructure_Algorithm-Quadtree/)
* [https://chessire.tistory.com/entry/쿼드트리Quad-tree](https://chessire.tistory.com/entry/쿼드트리Quad-tree)


<!--
![](https://velog.velcdn.com/images/youngjun_10/post/a03c18dc-c0ae-4e94-b575-7b9617914149/image.png)

###  목적

새벽에 백준문제를 풀다가 쿼드 트리라는 개념을 봤는데 어디서 많이 들어본 개념인데 생각이 안나서 이번기회에 정리를 해서 내것으로
만들려고한다.

###  쿼드트리(Quad Tree)

데이터베이스 검색에 사용되는 트리구조이다. 항상 하나의 노드에 4개의 가지로 구성되는 트리 구조로서 구하는 레코드가 나타날때까지 계속 4개로
등분해서 검색이 행해진다. 상급레벨의 정보를 공유하는 같은 사이즈의 네개의 하위레벨을 갖는 트리의 노드를 표현하는 데이터 우계구조를
사용한다.

또한 그리드의 사분면 내에서 속성의 중복 제거에 기초한 래스터 압축 기법으로도 불린다. 공간을 4개의 정사각형(이를
Quadrant라고한다.)으로 계층적으로 분할하는 원리에 바탕을 둔 위계적 자료 구조이다. 사지수형 자료 구조는 대상체를 정보의 조밀 여부에
따라 세분해 나가는 방법이며 계층적 래스터 자료 구조의 변형이다. 계층적 자료 구조란 공간 분할에 사용되는 단위의 크기를 달리해
데이터베이스를 구축한 기번으로 넓은 지역에 대한 데이터베이스 구축에 매우 용이하게 적용될 수 있다.

원 자료의 정보 그대로 자료를 저장하고 있어 단순한 자료압축의 한 기법이 아니라 래스터의 또 다른 자료구조로서 인식되기도 한다. 래스터
표현에서 상세한 위치를 나타낼때 격자의 수가 폭발적으로 증가하기 때문에 압축한 자료 구조가 필요한데 그 대표적인 것이 사지수형이며 이에는 면
사지수형(Area Quadtree)과 점 사지수형(Point Quadtree)이 있다.

![](https://velog.velcdn.com/images/youngjun_10/post/409f278a-54f6-46b5-a27b-6d3881c7c372/image.png)

###  공간 데이터(Spatial Data) 구성

공간 데이터: 공간 데이터 레코드는 속성으로서 위치 감각을 포함한다. 일반적으로 위치는 좌표 데이터(2D 또는 3D)로 표시된다. 위치를
핵심 값으로 공간 데이터를 검색하려면 검색시 두 가지 이상의 대안 중 선택을 효율적으로 표현하는 데이터 구조가 필요하다. 2D 데이터에 대한
한 가지 접근법은 쿼드 트리를 사용하는 것인데 각 내부 노드는 좌표 공간을 분해하여 얻은 서로 다른 영역을 나타내는 최대 4개의 자식을 가질
수 있다.

###  공간 분해

이진 검색 트리에서 트리의 구조는 어떤 데이터 값이 삽입되는지 뿐만 아니라 어떤 순서로 삽입되는지에 따라 달라진다. 점 영역 쿼드 틀리의
구조는 그것이 포함하는 데이터 값에 의해 전적으로 결정되며 삽입 순서와는 독립적이다.  
실제로 PR 쿼드 트리의 각 노드는 2D 좌표 공간에서 특정 영역을 나타낸다. 내부 노드는 정확히 4개의 자식노드(노드 중에 일부는 비어
있을 수 있다.)를 가지고 있으며 각각은 부모 노드에 의해 표현되는 영역의 서로 다른 합동 사분면을 나타낸다. 내부 노드는 데이터를 저장하지
않는다. 리프 노드는 단일 데이터 값을 유지한다. 따라서 삽입이 수행될 때 좌표 공간이 분할되어 하나의 점 이상을 포함하는 영역이 없다.
PR쿼드 트리는 유한 경계 좌표 공간의 점을 나타낸다.

###  공간 분할 좌표

256 x 256 좌표 공간에서 점들의 집합을 보자

![](https://velog.velcdn.com/images/youngjun_10/post/f43ce9da-e407-4c49-a42f-93dfd10afccb/image.png)

![](https://velog.velcdn.com/images/youngjun_10/post/4ab5a5da-a10f-4c72-94d0-692c5d1a80db/image.png)

![](https://velog.velcdn.com/images/youngjun_10/post/d09f80ba-
fffd-4f2f-af63-b87e26f9b3da/image.png)

좌표 공간의 세분화는 포인트가 PR 쿼드 트리에 추가될때 분할 되는 방법을 나타낸다.

###  PR 쿼드 트리 삽입

첫 번째 점인 A를 삽입하면 A를 보유한 리프 노드가 생성된다. 그 다음 B를 삽입하면 원래 좌표 공간이 4개의 사분면으로 분할되고 루트가
비어 있지 않은 두 자식이 있는 내부 노드로 대체된다.

![](https://velog.velcdn.com/images/youngjun_10/post/e9f267cd-1f3f-4616-b068-e6a1a2396fed/image.png)

각 노드가 논리적으로 표현한 영역의 SW 및 NE 코너와 리프 노드에 저장된 데이터 값을 보여준다. 구현에서 노드는 자신의 영역을 명시적으로
정의하는 정보를 저장하지 않으며 빈 리프 노드도 할당되지 않을 것이다.

###  삽입 중 리프 분할

C를 삽입하면 자연스럽게 빈 리프로 들어가기 때문에 좌표 공간이 추가로 분할 되지 않는다. 하지만 D를 삽입하면 SE사분면이 분할 되어 B와
D가 분리된다.

![](https://velog.velcdn.com/images/youngjun_10/post/c16730b6-6b25-4240-8f07-61cdf6b9ca04/image.png)

###  다중 분할

이제 값 E(80,80)가 트리에 삽입되었다고 가정해보자. A지점과 동일한 영역에 속하며 (0,0)에서 (128,128)까지 해당한다.
그러나 이 영역을 분할하면 세개의 빈 영역과 A와 E가 모두 있는 영역(64,64)에서 (128,128)이 생성된다. 그렇기 떄문에 그
지역은 다시 분할되어야 한다. 이렇게 하면 A와 E가 두개의 개별 영역으로 분리된다. 만약 그렇지 않다면, A와 E 둘다 있는 영역은 완전히
분리될 때까지 단시 분할되고 필요하다면 반복적으로 분할된다.

![](https://velog.velcdn.com/images/youngjun_10/post/a8bb94a0-12f5-4354-8b2b-53ebdcff787b/image.png)

그렇기 때문에 E를 삽입하면 다음 트리가 생성된다.

![](https://velog.velcdn.com/images/youngjun_10/post/c3b50baa-1d17-40c1-924d-e04897de953d/image.png)

삽입은 재귀적으로 진행되며 적절한 리프 노드(빈 것으로 추정)가 발견될 때까지 하강한 다음 각 리프로 표현되는 영역 내에 하나 이상의 점이
없을 때까지 분할 및 하강한다. 점들이 서로 충분히 가깝게 있는 경우, 한번의 삽입으로 관련 하위 트리에 많은 수준을 추가할 수 있다. 물론
삽입 시 분할이 필요하지 않을 수도 있다. 트리의 모양은 데이터 요소가 추가되는 순서와 완전히 독립적이다.

###  PR Quadtree Deletion

삭제시에는 항상 리프 노드가 적어도 하나는 제거된다.. 다음 트리에서 A를 삭제할거다.

![](https://velog.velcdn.com/images/youngjun_10/post/4231ea29-21a8-499d-bbf3-3c2af2c5ad3b/image.png)

상위 포인터를 null로 설정하면 트리에서 리프 노드가 제거되고 추가 작업이 필요하지 않다.

![](https://velog.velcdn.com/images/youngjun_10/post/f3b92bc2-90db-4a2a-b37c-81bdcfa8ef9f/image.png)

반면에 리프 노드를 삭제하면 상위 노드가 언더플로 될 수 있다. 이번에는 B를 한번 삭제할거다.

이제 상위 노드에서 하위 노드가 하나만 있으므로 반드시 분할해야 할 이유가 없다. 따라서 상위 노드를 나머지 하위노드(리프)로 교체하여
분기를 축소 시킬 수 있다.

![](https://velog.velcdn.com/images/youngjun_10/post/052bb582-6e51-4a62-9d17-09bc78c50369/image.png)

branch를 축소하면 다음과 같이 된다.

![](https://velog.velcdn.com/images/youngjun_10/post/9e543756-a794-4fb9-93b2-d17e6b570a7d/image.png)

이 트리의 루트 노드에 다른 자식이 없으면 branch 축소가 계속될 수 있다.

###  PR Quadtree Achilles' Heel

삽입된 데이터 포인트가 트리의 다른 데이터 포인트에 매우 가까운 경우, 이들을 분리하기 위해 많은 레벨의 파티셔닝이 필요할 수 있다.

![](https://velog.velcdn.com/images/youngjun_10/post/edf967ab-4179-4c30-a792-33b5352d0b6d/image.png)

PR 쿼드 트리의 최소 높이는 다음과 같을 수 있다.

![](https://velog.velcdn.com/images/youngjun_10/post/998d7754-b795-4da3-bd31-4eb69ab2a3c0/image.png)

여기서 s는 world의 한 변의 길이이고 d는 트리의 두 데이터 점 사이의 최소 거리이다.

###  버킷을 사용한 PR 쿼드 트리

각 리프 노드가 하나 이상의 데이터 객체를 저장할 수 있게 함으로써 stalky PR 쿼드 트리 분기(branch)의 문제를 완화할 수
있다.

###  마무리

새벽에 한참 생각했는데 알고리즘이 어려운것같다. 계속 이 알고리즘을 생각해봐야할것같다.


-->

<!--






-->

<!--
트리의 자식 노드가 4개인 트리를 뜻하고 있다.

3D 데이터를 표현하기 위한 자료구조를 '장면 그래프( Scene Graph )'라고 부르는데, 이도 역시 그에 포함된다.

장면 그래프( Scene Graph )에는 쿼드 트리 이외에도 이진트리(2)와 옥트리(8)가 존재한다.

말 그대로 이진트리는 자식노드가 2개, 옥트리는 자식 노드가 8개가 있는 트리를 의미한다.

쿼드 트리는 일반적으로 상하 개념이 없어서 3차원 세계를 4개의 평면으로 분할하지만,

옥트리는 4개로 분할한 쿼드트리에서 상하의 분할 평면으로 나누어 총 8개의 자식 노드를 갖게 된다.

일반적으로 지형( Terrain )에 사용된다.

** 정의  ** : 공간을 재귀적인 호출로(Recursive ) 4개의 자식 노드로 분할하는 방법

지형으로 설명을 하자면

초기에 하나의 넓은 월드의 지형을 1/4 로 나눈다.

그렇게 나온 4개의 노드를 부모로서 다시 1/4로 각각을 나눈다.

그럼 초기 하나의 월드에는 현재 16개의 노드가 존재한다.

이런 식으로 재귀적인 호출을 통해 각 노드간의 간격이 1보다 작거나 같을 때까지 분할한다.

![](https://blog.kakaocdn.net/dn/cVR5RB/btqW8HbJJN3/5xF4MeXmTzfWRq9cnR6DTK/img.png)
출처 : https://blog.naver.com/maelblood/20168518863

####  **관련 알고리즘 문제 2개**

[ www.acmicpc.net/problem/1992 ](https://www.acmicpc.net/problem/1992)

[ 1992번: 쿼드트리  첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1 ≤ N ≤
64의 범위를 가진다. 두 번째 줄부터는 길이 N의 문자열이 N개 들어온다. 각 문자열은 0 또  www.acmicpc.net
](https://www.acmicpc.net/problem/1992)

해당 문제는

![](https://blog.kakaocdn.net/dn/dMyQxe/btqWVRAjFec/1IkIQk668j3akfFPEArI5k/img.png)

왼쪽과 같은 그림을 오른쪽과 같이 표현하며

![](https://blog.kakaocdn.net/dn/TTwVo/btqWXa69qXF/wpBEpjJDGl9sjrZvCx5kS0/img.png)

이와 같이 4분할 해주고, 한번 더

![](https://blog.kakaocdn.net/dn/Y5uwl/btqW4iDl63R/sXgWkOkkOCTMHQVKVU5Ji1/img.png)

이렇게 다시 나눠준 결과를

> (0(0011)(0(0111)01)1)

이렇게 표현 해주고 있다.

왼쪽부터 0이 왼쪽위의 0이 16개로 나눠준 부분이고,

그 다음 괄호 0011 은 오른쪽 위에 0 4개 2칸/ 1 4개 칸이고,

그 다음 괄호 0(0111)01 은 왼쪽아래에 0 4개와 0 1 1 1 / 0 4개 / 1 4개를 표현했다.

마지막 괄호 안 1이 오른쪽 아래 1 16개로 나타내고 있다.

해당 문제에서는 입력 값이

![](https://blog.kakaocdn.net/dn/biJvOH/btqW4ipNGI5/T1HTfqfXtIiWQCcEeVv2K1/img.png)

2의 제곱수로 64까지만 제한하고 있다. 예제로 입력된 값은 해당 값으로 출력 된다.

![](https://blog.kakaocdn.net/dn/tJ9Am/btqWWsGYjCR/kjj0aENDI72BNfydRALIw0/img.png)

**풀이방법**

    
    
    #include <iostream>
    #include <string>
    using namespace std;
    
    #define MAX 64
    int arr[MAX][MAX];
    void compress(int n, int y, int x)
    {
    	//기저 사례
    	if (n == 1)
    	{
    		cout << arr[y][x];
    		return;
    	}
    	bool bIsZero = true;
    	bool bIsOne = true;
    
    	for (int i = y; i < y + n; i++)
    	{
    		for (int j = x; j < x + n; j++)
    		{
    			if (arr[i][j]==1)
    			{
    				bIsZero = false;
    			}
    			else
    			{
    				bIsOne = false;
    			}
    
    			if (bIsZero == false && bIsOne == false)
    			{
    				break;
    			}
    
    		}
    
    		if (bIsZero == false && bIsOne == false) //두개 다 섞여있다면
    		{
    			break; //바로 중단 
    		}
    	}
    
    
    
    	if (bIsZero)
    		cout << 0;
    	else if (bIsOne)
    		cout << 1;
    	else
    	{
    		cout << "(";
    		compress(n / 2, y, x); //2사분면
    		compress(n / 2, y, x + n / 2); //1사분면
    		compress(n / 2, y + n / 2, x); //3사분면
    		compress(n / 2, y + n / 2, x + n / 2); //4사분면
    		cout << ")";
    	}
    	return;
    
    }
    
    
    
    int main(void)
    {
    	ios_base::sync_with_stdio(0);
    	cin.tie(0);
    	int N;
    	cin >> N;
    
    
    
    	string s;
    	for (int i = 0; i < N; i++)
    	{
    		cin >> s;
    
    		for (int j = 0; j < N; j++)
    			arr[i][j] = s[j] - '0';
    	}
    
    
    
    	compress(N, 0, 0);
    
    	cout << "\n";
    
    	return 0;
    
    }
    
    

**또 다른 문제**

**[ algospot.com/judge/problem/read/QUADTREE
](https://algospot.com/judge/problem/read/QUADTREE) **

[ algospot.com :: QUADTREE  쿼드 트리 뒤집기 문제 정보 문제 대량의 좌표 데이터를 메모리 안에 압축해 저장하기 위해
사용하는 여러 기법 중 쿼드 트리(quad tree)란 것이 있습니다. 주어진 공간을 항상 4개로 분할해 재귀적  algospot.com
](https://algospot.com/judge/problem/read/QUADTREE)


-->

<!--






-->

<!--
  * ![](https://velog.velcdn.com/images/jk01019/post/00aba55f-2d84-45c5-9fb5-fa25affed9ce/image.png)
  * Quad tree는 계층적 데이터 구조 중 하나 
  * 이 구조는 2차원 공간을 표현하고 관리하는 데 효율적이며, 특히 이미지 처리, 공간 인덱싱, 그리고 로봇의 환경 인식 및 맵핑에서 중요한 역할 
  * Quad tree는 공간을 재귀적으로 네 개의 동일한 사분면으로 분할하여 구성 
  * 각 노드는 공간의 한 부분을 대표하며, ` 그 공간이 더 이상 분할할 필요가 없거나 일정 기준에 도달할 때까지 ` 네 개의 자식 노드(사분면)로 나뉩니다. 

###  Quad Tree의 기본 구조

Quad tree의 각 노드는 최대 네 개의 자식을 가질 수 있습니다:

  * 북서(NW, North-West) 
  * 북동(NE, North-East) 
  * 남서(SW, South-West) 
  * 남동(SE, South-East) 

###  Quad Tree의 사용

  1. **공간 분할(Spatial Partitioning)** : 

  * 로봇이 탐색하는 환경을 더 작고 관리하기 쉬운 부분으로 분할하여, 
  * 로봇이 효율적으로 경로를 계획하고 장애물을 회피할 수 있도록 

  2. **경로 계획(Path Planning)** : 

  * 로봇의 현재 위치와 목적지 사이의 최적 경로를 찾는 데 사용될 수 있음 
  * Quad tree는 공간을 분할함으로써 로봇이 탐색해야 할 영역을 줄이고, 계산 복잡성을 감소 

  3. **장애물 탐지(Obstacle Detection)** 및 **환경 매핑(Environment Mapping)**

  * 로봇이 주변 환경을 인식하고, 장애물의 위치를 정확히 파악하여 맵에 표시하는 데 유용 
  * 각 사분면은 장애물의 존재 유무에 따라 구분될 수 있으며, 이 정보는 로봇이 안전하게 탐색하도록 돕습니다. 

###  Quad Tree의 수학적 표현

  * Quad tree의 구현에는 수학적 수식이 직접적으로 적용되는 경우가 적지만, 기본적으로는 2차원 공간을 재귀적으로 분할하는 알고리즘을 기반으로 합니다. 
  * **공간을 분할하는 기준은 특정 영역의 크기, 포함된 데이터의 양, 또는 미리 정의된 깊이 등**
  * 예를 들어, 공간 (S)를 분할하는 기준이 되는 함수를 (f(S))라고 할 때, (f(S))가 특정 임계값보다 크면 (S)를 네 개의 사분면으로 분할합니다. 이 과정은 재귀적으로 반복됩니다. 

###  결론

  * Quad tree는 로봇 내비게이션에서 공간을 효율적으로 표현하고 처리하는 데 매우 유용한 데이터 구조 
  * 이를 통해 로봇은 복잡한 환경에서도 효과적으로 탐색하고, 장애물을 회피하며, 목적지까지의 최적 경로를 계획할 수 있습니다. 

* * *

##  Quad tree와 path planning

  * Quad tree 구조는 로봇 경로 계획(Robot Path Planning)에 있어서 환경을 효율적으로 나누고 관리하는 방법으로 자주 사용됩니다. 
  * 로봇 경로 계획에서는 로봇이 출발지에서 목적지까지 장애물을 피해 최적 또는 효율적인 경로를 찾는 것이 목표 
  * Quad tree는 이러한 과정을 지원하기 위해 2차원 공간을 재귀적으로 네 개의 사분면으로 분할하여 관리하는 데이터 구조 
  * 이를 통해 대규모 환경에서도 빠르게 특정 영역을 조회하고, 경로 계획을 수립할 수 있습니다. 
  * 다음은 Quad tree를 이용한 로봇 경로 계획의 구체적인 로직입니다. 

###  1\. 환경 분할

  * **초기 단계** : 
    * 전체 환경을 대표하는 Quad tree의 루트 노드를 생성합니다. 
    * 이 노드는 전체 맵을 나타냅니다. 
  * **분할 과정** : 
    * 환경 내에 장애물이 포함된 영역이나 경로 계획에 중요한 특징을 가진 영역을 기준으로 현재 노드를 네 개의 사분면으로 분할합니다. 
    * 각 사분면은 자식 노드로 표현되며, 이 과정은 지정된 분할 기준(예: 최소 영역 크기, 장애물 밀도)을 만족할 때까지 재귀적으로 수행됩니다. 

###  2\. 경로 탐색 알고리즘과의 통합

  * **노드 평가** : 
    * 각 Quad tree 노드는 로봇이 통과할 수 있는 공간인지, 장애물이 있는 공간인지 등의 정보를 포함할 수 있습니다. 
    * 이 정보는 A* 같은 경로 탐색 알고리즘에서 특정 노드를 거쳐가는 경로의 가능성과 비용을 평가하는 데 사용됩니다. 
  * **경로 탐색** : 
    * 경로 탐색 알고리즘은 Quad tree의 구조를 이용하여 시작 노드에서 목표 노드까지의 경로를 찾습니다. 
    * 이 과정에서 불필요한 영역의 탐색을 최소화하고, 효율적으로 목적지까지의 경로를 계산할 수 있습니다. 

###  3\. 동적 환경 대응

  * **환경 업데이트** : 
    * 로봇이 이동하는 환경이 동적으로 변할 수 있습니다 
    * **이러한 변경 사항이 감지되면, 관련된 Quad tree의 노드를 업데이트하고 필요한 경우 재분할하여 경로를 다시 계산합니다.**
  * **경로 재계산** : 
    * **환경의 변화로 인해 기존의 경로가 더 이상 최적이거나 실행 가능하지 않게 될 경우, 변경된 Quad tree를 기반으로 새로운 경로를 계산**

###  4\. 최적화와 휴리스틱

  * **휴리스틱 함수** : 
    * 경로 탐색의 효율성을 높이기 위해 휴리스틱 함수를 사용하여 각 노드의 가치를 추정할 수 있습니다. 
    * 이 함수는 목적지까지의 예상 거리, 장애물을 피하는 비용 등을 고려할 수 있습니다. 
  * **최적화 기법** : 
    * 다양한 최적화 기법을 적용하여 Quad tree 구조의 생성과 경로 탐색 과정을 더 빠르고 효율적으로 만들 수 있습니다. 
    * 예를 들어, 불필요한 노드의 생성을 방지하거나, 경로 탐색 과정에서 우선 순위를 설정하여 중요한 영역을 먼저 탐색하도록 할 수 있습니다. 
  * Quad tree 구조를 사용하는 로봇 경로 계획은 이러한 로직을 기반으로 하여 복잡하고 다양한 환경에서 로봇이 효율적으로 목적지까지 이동할 수 있도록 도와줍니다. 

* * *

##  quad tree graph grenetation VS grid map graph grenetation

  * Quad tree 구조를 사용한 로봇 경로 계획과 일반적인 그리드 맵(grid map)을 사용한 경로 계획을 비교했을 때, 각각의 접근 방식은 고유한 장단점을 가지고 있습니다. 이러한 차이는 데이터 구조의 효율성, 처리 속도, 메모리 사용량 등 여러 측면에서 나타납니다. 

###  Quad Tree의 장점

  1. **메모리 효율성** : 

  * **Quad tree는 공간을 재귀적으로 분할하여 관리하기 때문에, 비어 있는 공간이 많은 환경에서 메모리 사용량을 크게 줄일 수 있습니다.**

  2. **동적 환경 대응력** : 

  * **환경에 변화가 생겼을 때, 해당 영역만을 대상으로 빠르게 트리 구조를 업데이트하고 재분할할 수 있어, 동적 환경에서의 경로 재계산이 효율적**

  3. **적응적 공간 분해능** : 

  * **Quad tree는 지역적 특성에 따라 공간을 다르게 분할할 수 있어, 장애물이 밀집되어 있는 영역을 더 세밀하게 나누어 처리할 수 있습니다.**
  * 이는 경로 계획의 정밀도와 효율성을 높일 수 있습니다. 

###  Quad Tree의 단점

  2. **탐색 시간** : **일부 경우에서 Quad tree의 탐색 속도가 그리드 맵에 비해 느릴 수 있습니다.** 특히, 공간을 매우 세밀하게 분할한 경우, 경로 탐색 알고리즘의 탐색 깊이가 깊어져 탐색 시간이 증가할 수 있습니다. 
  3. **비균일 탐색 성능** : **공간의 분할이 비균일하게 이루어질 경우, 경로 탐색의 성능이 예측하기 어렵고, 일관성이 떨어질 수 있습니다.** 이는 특히, 장애물 분포가 균일하지 않은 환경에서 문제가 될 수 있습니다. 

###  Grid Map의 장점

  2. **탐색 속도** : **동일한 크기의 셀로 구성된 그리드 맵에서는 경로 탐색 알고리즘의 계산 속도가 일반적으로 빠르며, 특히 단순한 환경에서 효율적**

###  Grid Map의 단점

  1. **메모리 사용량** : **특히 대규모 환경에서, 그리드 맵은 빈 공간도 동일하게 저장해야 하므로, Quad tree에 비해 메모리 사용량이 많을 수 있음**
  2. **정밀도와 메모리 사용량의 트레이드오프** : **그리드의 크기를 줄여 공간의 정밀도를 높이면, 메모리 사용량이 기하급수적으로 증가합니다.**
  3. **동적 환경 대응** : **환경의 변화를 반영하기 위해서는 전체 맵을 업데이트하거나 재구성해야 하며, 이는 비효율적일 수 있습니다.**

* * *

##  Quad tree에서 보통 주행 가능한 graph generation은 어떤 방식으로 진행돼?

  * Quad tree 구조에서 주행 가능한 그래프(Traversable Graph)를 생성하는 과정은 일반적으로, 
  * 환경의 공간적 특성을 분석하여 주행 가능한 영역과 장애물을 구분하고, 이 정보를 기반으로 주행 경로를 계획할 수 있는 그래프를 구성하는 방식으로 진행됩니다. 
  * Quad tree의 장점은 공간을 효율적으로 분할하여 관리할 수 있다는 점입니다. 

###  Quad Tree를 이용한 그래프 생성 방식

  1. **환경 분할 및 표현** : 

  * Quad tree를 사용하여 환경을 네 개의 사분면으로 재귀적으로 분할합니다. 
  * 이때, 각 사분면(노드)은 장애물이 있는 영역인지, 주행 가능한 영역인지를 나타냅니다. 
  * 분할의 기준은 특정 임계값(예: 사분면 내 장애물의 비율, 최소 사분면 크기 등)에 따라 결정될 수 있습니다. 

  2. **노드 분류** : 

  * **각 Quad tree 노드를 주행 가능한 영역, 장애물 영역, 혼합 영역 등으로 분류합니다.**
  * **이 과정에서 주행 가능한 영역만을 추출하여 그래프의 노드로 사용할 수 있음**

  3. **연결성 분석** : 

  * **주행 가능한 노드들 사이의 연결성을 분석하여, 이들을 연결하는 에지를 생성**
  * 연결성 분석은 노드들 사이의 거리, 장애물의 존재 유무, 주행 가능 영역의 연속성 등을 고려하여 진행됩니다. 

  4. **그래프 최적화** : 

  * **생성된 그래프에서 불필요한 노드나 에지를 제거하고, 경로 계획의 효율성을 높이기 위해 그래프를 최적화합니다.**
  * 이 과정에서 주행 경로의 길이, 안전성, 주행 비용 등을 고려할 수 있습니다. 

###  Quad Tree와 Voronoi 그래프의 통합 사용

  * Quad tree 구조에서도 Voronoi 그래프를 통한 경로 계획 방식을 적용할 수 있습니다. 
  * 이 경우, Quad tree는 주로 환경을 효율적으로 분할하고 관리하는 데 사용되며, Voronoi 그래프는 이러한 환경 내에서 주행 가능한 경로를 찾는 데 활용됩니다. 
  * **Voronoi 기반 경로 생성** : 
    * 환경 내의 장애물을 기준으로 Voronoi 다이어그램을 생성하고, 이를 통해 로봇이 장애물로부터 안전한 거리를 유지하며 이동할 수 있는 경로를 계획합니다. 
  * **Quad tree와의 통합** : 
    * Quad tree로 표현된 환경 정보를 사용하여 Voronoi 다이어그램을 생성할 때, 장애물의 위치와 주행 가능한 영역을 더 정확하게 식별할 수 있습니다. 
    * 이를 통해 더 효율적이고 안전한 경로 계획이 가능해집니다. 
  * Quad tree 구조를 이용한 그래프 생성 방식은 환경의 복잡성에 따라 다양하게 조정될 수 있으며, 경로 계획의 목적과 조건에 따라 다른 경로 계획 알고리즘과 결합하여 사용될 수 있습니다. 
  * Quad tree의 재귀적인 특성과 공간 분할 능력을 활용하면, 대규모 또는 복잡한 환경에서도 효율적으로 주행 가능한 경로를 찾아낼 수 있는 강력한 도구가 됩니다. 


-->

<!--






-->

<!--
Tree data structure in which each internal node has exactly four children, to
partition a 2D area

[
![](https://upload.wikimedia.org/wikipedia/commons/thumb/8/8b/Point_quadtree.svg/300px-
Point_quadtree.svg.png) ](/wiki/File:Point_quadtree.svg) A point-region
quadtree with point data. Bucket capacity 1.  [
![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d7/Quadtree_compression_of_an_image.gif/300px-
Quadtree_compression_of_an_image.gif)
](/wiki/File:Quadtree_compression_of_an_image.gif) Quadtree compression of an
image step by step. Left shows the compressed image with the tree bounding
boxes while the right shows just the compressed image

A **quadtree** is a [ tree data structure ](/wiki/Tree_data_structure "Tree
data structure") in which each internal node has exactly four children.
Quadtrees are the two-dimensional analog of [ octrees ](/wiki/Octree "Octree")
and are most often used to partition a two-dimensional space by recursively
subdividing it into four quadrants or regions. The data associated with a leaf
cell varies by application, but the leaf cell represents a "unit of
interesting spatial information".

The subdivided regions may be square or rectangular, or may have arbitrary
shapes. This data structure was named a quadtree by [ Raphael Finkel
](/wiki/Raphael_Finkel "Raphael Finkel") and [ J.L. Bentley
](/wiki/J.L._Bentley "J.L. Bentley") in 1974.  [  1  ]  A similar partitioning
is also known as a _Q-tree_ .

All forms of quadtrees share some common features:

  * They decompose space into adaptable cells. 
  * Each cell (or bucket) has a maximum capacity. When maximum capacity is reached, the bucket splits. 
  * The tree directory follows the spatial decomposition of the quadtree. 

A **tree-pyramid** ( **T-pyramid** ) is a "complete" tree; every node of the
T-pyramid has four child nodes except leaf nodes; all leaves are on the same
level, the level that corresponds to individual pixels in the image. The data
in a tree-pyramid can be stored compactly in an array as an [ implicit data
structure ](/wiki/Implicit_data_structure "Implicit data structure") similar
to [ the way a complete binary tree can be stored compactly in an array
](/wiki/Binary_heap#Heap_implementation "Binary heap") .  [  2  ]

[
![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/2D_Binary_Index.svg/220px-2D_Binary_Index.svg.png)
](/wiki/File:2D_Binary_Index.svg) An example of a recursive [ binary space
partitioning ](/wiki/Binary_space_partitioning "Binary space partitioning")
quadtree for a 2D index.

Quadtrees may be classified according to the type of data they represent,
including areas, points, lines and curves. Quadtrees may also be classified by
whether the shape of the tree is independent of the order in which data is
processed. The following are common types of quadtrees.

The region quadtree represents [ a partition of space
](/wiki/Space_partitioning "Space partitioning") in two dimensions by
decomposing the region into four equal quadrants, subquadrants, and so on with
each leaf node containing data corresponding to a specific subregion. Each
node in the tree either has exactly four children, or has no children (a leaf
node). The height of quadtrees that follow this decomposition strategy (i.e.
subdividing subquadrants as long as there is interesting data in the
subquadrant for which more refinement is desired) is sensitive to and
dependent on the spatial distribution of interesting areas in the space being
decomposed. The region quadtree is a type of [ trie ](/wiki/Trie "Trie") .

A region quadtree with a depth of n may be used to represent an image
consisting of 2  n  × 2  n  pixels, where each pixel value is 0 or 1. The root
node represents the entire image region. If the pixels in any region are not
entirely 0s or 1s, it is subdivided. In this application, each leaf node
represents a block of pixels that are all 0s or all 1s. Note the potential
savings in terms of space when these trees are used for storing images; images
often have many regions of considerable size that have the same colour value
throughout. Rather than store a big 2-D array of every pixel in the image, a
quadtree can capture the same information potentially many divisive levels
higher than the pixel-resolution sized cells that we would otherwise require.
The tree resolution and overall size is bounded by the pixel and image sizes.

A region quadtree may also be used as a variable resolution representation of
a data field. For example, the temperatures in an area may be stored as a
quadtree, with each leaf node storing the average temperature over the
subregion it represents.

The point quadtree  [  3  ]  is an adaptation of a [ binary tree
](/wiki/Binary_tree "Binary tree") used to represent two-dimensional point
data. It shares the features of all quadtrees but is a true tree as the center
of a subdivision is always on a point. It is often very efficient in comparing
two-dimensional, ordered data points, usually operating in [ O(log n)
](/wiki/Big_O_notation "Big O notation") time. Point quadtrees are worth
mentioning for completeness, but they have been surpassed by [ _k_ -d trees
](/wiki/K-d_tree "K-d tree") as tools for generalized binary search.  [  4  ]

Point quadtrees are constructed as follows. Given the next point to insert, we
find the cell in which it lies and add it to the tree. The new point is added
such that the cell that contains it is divided into quadrants by the vertical
and horizontal lines that run through the point. Consequently, cells are
rectangular but not necessarily square. In these trees, each node contains one
of the input points.

Since the division of the plane is decided by the order of point-insertion,
the tree's height is sensitive to and dependent on insertion order. Inserting
in a "bad" order can lead to a tree of height linear in the number of input
points (at which point it becomes a linked-list). If the point-set is static,
pre-processing can be done to create a tree of balanced height.

####  Node structure for a point quadtree

[  [ edit  ](/w/index.php?title=Quadtree&action=edit&section=4 "Edit section:
Node structure for a point quadtree") ]

A node of a point quadtree is similar to a node of a [ binary tree
](/wiki/Binary_tree "Binary tree") , with the major difference being that it
has four pointers (one for each quadrant) instead of two ("left" and "right")
as in an ordinary binary tree. Also a key is usually decomposed into two
parts, referring to x and y coordinates. Therefore, a node contains the
following information:

  * four pointers: quad[‘NW’], quad[‘NE’], quad[‘SW’], and quad[‘SE’] 
  * point; which in turn contains: 
    * key; usually expressed as x, y coordinates 
    * value; for example a name 

###  Point-region (PR) quadtree

[  [ edit  ](/w/index.php?title=Quadtree&action=edit&section=5 "Edit section:
Point-region \(PR\) quadtree") ]

Point-region (PR) quadtrees  [  5  ]  [  6  ]  are very similar to region
quadtrees. The difference is the type of information stored about the cells.
In a region quadtree, a uniform value is stored that applies to the entire
area of the cell of a leaf. The cells of a PR quadtree, however, store a list
of points that exist within the cell of a leaf. As mentioned previously, for
trees following this decomposition strategy the height depends on the spatial
distribution of the points. Like the point quadtree, the PR quadtree may also
have a linear height when given a "bad" set.

Edge quadtrees  [  7  ]  [  8  ]  (much like PM quadtrees) are used to store
lines rather than points. Curves are approximated by subdividing cells to a
very fine resolution, specifically until there is a single line segment per
cell. Near corners/vertices, edge quadtrees will continue dividing until they
reach their maximum level of decomposition. This can result in extremely
unbalanced trees which may defeat the purpose of indexing.

###  Polygonal map (PM) quadtree

[  [ edit  ](/w/index.php?title=Quadtree&action=edit&section=7 "Edit section:
Polygonal map \(PM\) quadtree") ]

The polygonal map quadtree (or PM Quadtree) is a variation of quadtree which
is used to store collections of polygons that may be degenerate (meaning that
they have isolated vertices or edges).  [  9  ]  [  10  ]  A big difference
between PM quadtrees and edge quadtrees is that the cell under consideration
is not subdivided if the segments meet at a vertex in the cell.

There are three main classes of PM Quadtrees, which vary depending on what
information they store within each black node. PM3 quadtrees can store any
amount of non-intersecting edges and at most one point. PM2 quadtrees are the
same as PM3 quadtrees except that all edges must share the same end point.
Finally PM1 quadtrees are similar to PM2, but black nodes can contain a point
and its edges or just a set of edges that share a point, but you cannot have a
point and a set of edges that do not contain the point.

###  Compressed quadtrees

[  [ edit  ](/w/index.php?title=Quadtree&action=edit&section=8 "Edit section:
Compressed quadtrees") ]

This section summarizes a subsection from a book by [ Sariel Har-Peled
](/wiki/Sariel_Har-Peled "Sariel Har-Peled") .  [  11  ]

If we were to store every node corresponding to a subdivided cell, we may end
up storing a lot of empty nodes. We can cut down on the size of such sparse
trees by only storing subtrees whose leaves have interesting data (i.e.
"important subtrees"). We can actually cut down on the size even further. When
we only keep important subtrees, the pruning process may leave long paths in
the tree where the intermediate nodes have degree two (a link to one parent
and one child). It turns out that we only need to store the node  u
{\displaystyle u}  ![{\\displaystyle
u}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8)
at the beginning of this path (and associate some meta-data with it to
represent the removed nodes) and attach the subtree rooted at its end to  u
{\displaystyle u}  ![{\\displaystyle
u}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8)
. It is still possible for these compressed trees to have a linear height when
given "bad" input points.

Although we trim a lot of the tree when we perform this compression, it is
still possible to achieve logarithmic-time search, insertion, and deletion by
taking advantage of [ _Z_ -order curves ](/wiki/Z-order_curve "Z-order curve")
. The _Z_ -order curve maps each cell of the full quadtree (and hence even the
compressed quadtree) in  O  (  1  )  {\displaystyle O(1)}  ![{\\displaystyle
O\(1\)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21)
time to a one-dimensional line (and maps it back in  O  (  1  )
{\displaystyle O(1)}  ![{\\displaystyle
O\(1\)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21)
time too), creating a total order on the elements. Therefore, we can store the
quadtree in a data structure for ordered sets (in which we store the nodes of
the tree).

We must state a reasonable assumption before we continue: we assume that given
two real numbers  α  ,  β  ∈  [  0  ,  1  )  {\displaystyle \alpha ,\beta \in
[0,1)}  ![{\\displaystyle \\alpha ,\\beta \\in
\[0,1\)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6021592a035c2548997fb8d86328c3d063459fca)
expressed as binary, we can compute in  O  (  1  )  {\displaystyle O(1)}
![{\\displaystyle
O\(1\)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21)
time the index of the first bit in which they differ. We also assume that we
can compute in  O  (  1  )  {\displaystyle O(1)}  ![{\\displaystyle
O\(1\)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21)
time the lowest common ancestor of two points/cells in the quadtree and
establish their relative _Z_ -ordering, and we can compute the floor function
in  O  (  1  )  {\displaystyle O(1)}  ![{\\displaystyle
O\(1\)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21)
time.

With these assumptions, point location of a given point  q  {\displaystyle q}
![{\\displaystyle
q}](https://wikimedia.org/api/rest_v1/media/math/render/svg/06809d64fa7c817ffc7e323f85997f783dbdf71d)
(i.e. determining the cell that would contain  q  {\displaystyle q}
![{\\displaystyle
q}](https://wikimedia.org/api/rest_v1/media/math/render/svg/06809d64fa7c817ffc7e323f85997f783dbdf71d)
), insertion, and deletion operations can all be performed in  O  (  log  ⁡  n
)  {\displaystyle O(\log {n})}  ![{\\displaystyle O\(\\log
{n}\)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99)
time (i.e. the time it takes to do a search in the underlying ordered set data
structure).

To perform a point location for  q  {\displaystyle q}  ![{\\displaystyle
q}](https://wikimedia.org/api/rest_v1/media/math/render/svg/06809d64fa7c817ffc7e323f85997f783dbdf71d)
(i.e. find its cell in the compressed tree):

  1. Find the existing cell in the compressed tree that comes before  q  {\displaystyle q}  ![{\\displaystyle q}](https://wikimedia.org/api/rest_v1/media/math/render/svg/06809d64fa7c817ffc7e323f85997f783dbdf71d) in the _Z_ -order. Call this cell  v  {\displaystyle v}  ![{\\displaystyle v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597) . 
  2. If  q  ∈  v  {\displaystyle q\in v}  ![{\\displaystyle q\\in v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/899b2c7b5a59ed5fa421d6d977e35814d1d37b5f) , return  v  {\displaystyle v}  ![{\\displaystyle v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597) . 
  3. Else, find what would have been the lowest common ancestor of the point  q  {\displaystyle q}  ![{\\displaystyle q}](https://wikimedia.org/api/rest_v1/media/math/render/svg/06809d64fa7c817ffc7e323f85997f783dbdf71d) and the cell  v  {\displaystyle v}  ![{\\displaystyle v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597) in an uncompressed quadtree. Call this ancestor cell  u  {\displaystyle u}  ![{\\displaystyle u}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8) . 
  4. Find the existing cell in the compressed tree that comes before  u  {\displaystyle u}  ![{\\displaystyle u}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8) in the _Z_ -order and return it. 

Without going into specific details, to perform insertions and deletions we
first do a point location for the thing we want to insert/delete, and then
insert/delete it. Care must be taken to reshape the tree as appropriate,
creating and removing nodes as needed.

##  Some common uses of quadtrees

[  [ edit  ](/w/index.php?title=Quadtree&action=edit&section=9 "Edit section:
Some common uses of quadtrees") ]

##  Image processing using quadtrees

[  [ edit  ](/w/index.php?title=Quadtree&action=edit&section=10 "Edit section:
Image processing using quadtrees") ]

Quadtrees, particularly the  region quadtree  , have lent themselves well to
image processing applications. We will limit our discussion to binary image
data, though region quadtrees and the image processing operations performed on
them are just as suitable for colour images.  [  4  ]  [  16  ]

###  Image union / intersection

[  [ edit  ](/w/index.php?title=Quadtree&action=edit&section=11 "Edit section:
Image union / intersection") ]

One of the advantages of using quadtrees for image manipulation is that the
set operations of union and intersection can be done simply and quickly.  [  4
]  [  17  ]  [  18  ]  [  19  ]  [  20  ]  Given two binary images, the image
union (also called _overlay_ ) produces an image wherein a pixel is black if
either of the input images has a black pixel in the same location. That is, a
pixel in the output image is white only when the corresponding pixel in _both_
input images is white, otherwise the output pixel is black. Rather than do the
operation pixel by pixel, we can compute the union more efficiently by
leveraging the quadtree's ability to represent multiple pixels with a single
node. For the purposes of discussion below, if a subtree contains both black
and white pixels we will say that the root of that subtree is coloured grey.

The algorithm works by traversing the two input quadtrees (  T  1
{\displaystyle T_{1}}  ![{\\displaystyle
T_{1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f304724948a3ef606c4a92459e22b87a954d993)
and  T  2  {\displaystyle T_{2}}  ![{\\displaystyle
T_{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d1ba5f12fbb0ff766aec6e22148b429373608555)
) while building the output quadtree  T  {\displaystyle T}  ![{\\displaystyle
T}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ec7200acd984a1d3a3d7dc455e262fbe54f7f6e0)
. Informally, the algorithm is as follows. Consider the nodes  v  1  ∈  T  1
{\displaystyle v_{1}\in T_{1}}  ![{\\displaystyle v_{1}\\in
T_{1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e01cea50601988fb04d83193a115846ec18a7349)
and  v  2  ∈  T  2  {\displaystyle v_{2}\in T_{2}}  ![{\\displaystyle
v_{2}\\in
T_{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/177f07cab7f56d4ca5853833fda8cecc92037795)
corresponding to the same region in the images.

  * If  v  1  {\displaystyle v_{1}}  ![{\\displaystyle v_{1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/98d33f5d498d528bd8c10edc8ac8c34347f32b3a) or  v  2  {\displaystyle v_{2}}  ![{\\displaystyle v_{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/eb04c423c2cb809c30cac725befa14ffbf4c85f3) is black, the corresponding node is created in  T  {\displaystyle T}  ![{\\displaystyle T}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ec7200acd984a1d3a3d7dc455e262fbe54f7f6e0) and is colored black. If only one of them is black and the other is gray, the gray node will contain a subtree underneath. This subtree need not be traversed. 
  * If  v  1  {\displaystyle v_{1}}  ![{\\displaystyle v_{1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/98d33f5d498d528bd8c10edc8ac8c34347f32b3a) (respectively,  v  2  {\displaystyle v_{2}}  ![{\\displaystyle v_{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/eb04c423c2cb809c30cac725befa14ffbf4c85f3) ) is white,  v  2  {\displaystyle v_{2}}  ![{\\displaystyle v_{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/eb04c423c2cb809c30cac725befa14ffbf4c85f3) (respectively,  v  1  {\displaystyle v_{1}}  ![{\\displaystyle v_{1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/98d33f5d498d528bd8c10edc8ac8c34347f32b3a) ) and the subtree underneath it (if any) is copied to  T  {\displaystyle T}  ![{\\displaystyle T}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ec7200acd984a1d3a3d7dc455e262fbe54f7f6e0) . 
  * If both  v  1  {\displaystyle v_{1}}  ![{\\displaystyle v_{1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/98d33f5d498d528bd8c10edc8ac8c34347f32b3a) and  v  2  {\displaystyle v_{2}}  ![{\\displaystyle v_{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/eb04c423c2cb809c30cac725befa14ffbf4c85f3) are gray, then the corresponding children of  v  1  {\displaystyle v_{1}}  ![{\\displaystyle v_{1}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/98d33f5d498d528bd8c10edc8ac8c34347f32b3a) and  v  2  {\displaystyle v_{2}}  ![{\\displaystyle v_{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/eb04c423c2cb809c30cac725befa14ffbf4c85f3) are considered. 

While this algorithm works, it does not by itself guarantee a minimally sized
quadtree. For example, consider the result if we were to union a checkerboard
(where every tile is a pixel) of size  2  k  ×  2  k  {\displaystyle
2^{k}\times 2^{k}}  ![{\\displaystyle 2^{k}\\times
2^{k}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/74414f6e3b8d63d6dd77867ecfa6ff45b88296f4)
with its complement. The result is a giant black square which should be
represented by a quadtree with just the root node (coloured black), but
instead the algorithm produces a full 4-ary tree of depth  k  {\displaystyle
k}  ![{\\displaystyle
k}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40)
. To fix this, we perform a bottom-up traversal of the resulting quadtree
where we check if the four children nodes have the same colour, in which case
we replace their parent with a leaf of the same colour.  [  4  ]

The intersection of two images is almost the same algorithm. One way to think
about the intersection of the two images is that we are doing a union with
respect to the _white_ pixels. As such, to perform the intersection we swap
the mentions of black and white in the union algorithm.

###  Connected component labelling

[  [ edit  ](/w/index.php?title=Quadtree&action=edit&section=12 "Edit section:
Connected component labelling") ]

Consider two neighbouring black pixels in a binary image. They are _adjacent_
if they share a bounding horizontal or vertical edge. In general, two black
pixels are _connected_ if one can be reached from the other by moving only to
adjacent pixels (i.e. there is a path of black pixels between them where each
consecutive pair is adjacent). Each maximal set of connected black pixels is a
_connected component_ . Using the quadtree representation of images, [ Samet
](/wiki/Hanan_Samet "Hanan Samet") [  21  ]  showed how we can find and label
these connected components in time proportional to the size of the quadtree.
[  4  ]  [  22  ]  This algorithm can also be used for polygon colouring.

The algorithm works in three steps:

  * establish the adjacency relationships between black pixels 
  * process the equivalence relations from the first step to obtain one unique label for each connected component 
  * label the black pixels with the label associated with their connected component 

To simplify the discussion, let us assume the children of a node in the
quadtree follow the [ _Z_ -order ](/wiki/Z-order_curve "Z-order curve") (SW,
NW, SE, NE). Since we can count on this structure, for any cell we know how to
navigate the quadtree to find the adjacent cells in the different levels of
the hierarchy.

Step one is accomplished with a [ post-order traversal
](/wiki/Tree_traversal#Post-order "Tree traversal") of the quadtree. For each
black leaf  v  {\displaystyle v}  ![{\\displaystyle
v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)
we look at the node or nodes representing cells that are Northern neighbours
and Eastern neighbours (i.e. the Northern and Eastern cells that share edges
with the cell of  v  {\displaystyle v}  ![{\\displaystyle
v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)
). Since the tree is organized in _Z_ -order, we have the invariant that the
Southern and Western neighbours have already been taken care of and accounted
for. Let the Northern or Eastern neighbour currently under consideration be  u
{\displaystyle u}  ![{\\displaystyle
u}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8)
. If  u  {\displaystyle u}  ![{\\displaystyle
u}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8)
represents black pixels:

  * If only one of  u  {\displaystyle u}  ![{\\displaystyle u}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8) or  v  {\displaystyle v}  ![{\\displaystyle v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597) has a label, assign that label to the other cell 
  * If neither of them have labels, create one and assign it to both of them 
  * If  u  {\displaystyle u}  ![{\\displaystyle u}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8) and  v  {\displaystyle v}  ![{\\displaystyle v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597) have different labels, record this label equivalence and move on 

Step two can be accomplished using the [ union-find data structure
](/wiki/Disjoint-set_data_structure "Disjoint-set data structure") .  [  23  ]
We start with each unique label as a separate set. For every equivalence
relation noted in the first step, we union the corresponding sets. Afterwards,
each distinct remaining set will be associated with a distinct connected
component in the image.

Step three performs another post-order traversal. This time, for each black
node  v  {\displaystyle v}  ![{\\displaystyle
v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)
we use the union-find's _find_ operation (with the old label of  v
{\displaystyle v}  ![{\\displaystyle
v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)
) to find and assign  v  {\displaystyle v}  ![{\\displaystyle
v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)
its new label (associated with the connected component of which  v
{\displaystyle v}  ![{\\displaystyle
v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)
is part).

##  Mesh generation using quadtrees

[  [ edit  ](/w/index.php?title=Quadtree&action=edit&section=13 "Edit section:
Mesh generation using quadtrees") ]

This section summarizes a chapter from a book by Har-Peled and de Berg et al.
[  24  ]  [  25  ]

[ Mesh generation ](/wiki/Mesh_generation "Mesh generation") is essentially
the [ triangulation of a point set ](/wiki/Point-set_triangulation "Point-set
triangulation") for which further processing may be performed. As such, it is
desirable for the resulting triangulation to have certain properties (like
non-uniformity, triangles that are not "too skinny", large triangles in sparse
areas and small triangles in dense ones, etc.) to make further processing
quicker and less error-prone. Quadtrees built on the point set can be used to
create meshes with these desired properties.

[ ![](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Fig-mesh-gen-
balanced-leaves.svg/220px-Fig-mesh-gen-balanced-leaves.svg.png)
](/wiki/File:Fig-mesh-gen-balanced-leaves.svg) A balanced leaf has at most one
corner in a side.

Consider a leaf of the quadtree and its corresponding cell  v  {\displaystyle
v}  ![{\\displaystyle
v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)
. We say  v  {\displaystyle v}  ![{\\displaystyle
v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)
is _balanced_ (for mesh generation) if the cell's sides are intersected by the
corner points of neighbouring cells at most once on each side. This means that
the quadtree levels of leaves adjacent to  v  {\displaystyle v}
![{\\displaystyle
v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)
differ by at most one from the level of  v  {\displaystyle v}
![{\\displaystyle
v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)
. When this is true for all leaves, we say the whole quadtree is balanced (for
mesh generation).

Consider the cell  v  {\displaystyle v}  ![{\\displaystyle
v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)
and the  5  ×  5  {\displaystyle 5\times 5}  ![{\\displaystyle 5\\times
5}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8dc635bb09101d63ece07af4a1a3883f75368dd8)
neighbourhood of same-sized cells centred at  v  {\displaystyle v}
![{\\displaystyle
v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)
. We call this neighbourhood the _extended cluster_ . We say the quadtree is
_well-balanced_ if it is balanced, and for every leaf  u  {\displaystyle u}
![{\\displaystyle
u}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8)
that contains a point of the point set, its extended cluster is also in the
quadtree and the extended cluster contains no other point of the point set.

Creating the mesh is done as follows:

  1. Build a quadtree on the input points. 
  2. Ensure the quadtree is balanced. For every leaf, if there is a neighbour that is too large, subdivide the neighbour. This is repeated until the tree is balanced. We also make sure that for a leaf with a point in it, the nodes for each leaf's extended cluster are in the tree. 
  3. For every leaf node  v  {\displaystyle v}  ![{\\displaystyle v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597) that contains a point, if the extended cluster contains another point, we further subdivide the tree and rebalance as necessary. If we needed to subdivide, for each child  u  {\displaystyle u}  ![{\\displaystyle u}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8) of  v  {\displaystyle v}  ![{\\displaystyle v}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597) we ensure the nodes of  u  {\displaystyle u}  ![{\\displaystyle u}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8) 's extended cluster are in the tree (and re-balance as required). 
  4. Repeat the previous step until the tree is well-balanced. 
  5. Transform the quadtree into a triangulation. 

We consider the corner points of the tree cells as vertices in our
triangulation. Before the transformation step we have a bunch of boxes with
points in some of them. The transformation step is done in the following
manner: for each point, warp the closest corner of its cell to meet it and
triangulate the resulting four quadrangles to make "nice" triangles (the
interested reader is referred to chapter 12 of Har-Peled  [  24  ]  for more
details on what makes "nice" triangles).

The remaining squares are triangulated according to some simple rules. For
each regular square (no points within and no corner points in its sides),
introduce the diagonal. Due to the way in which we separated points with the
well-balancing property, no square with a corner intersecting a side is one
that was warped. As such, we can triangulate squares with intersecting corners
as follows. If there is one intersected side, the square becomes three
triangles by adding the long diagonals connecting the intersection with
opposite corners. If there are four intersected sides, we split the square in
half by adding an edge between two of the four intersections, and then connect
these two endpoints to the remaining two intersection points. For the other
squares, we introduce a point in the middle and connect it to all four corners
of the square as well as each intersection point.

At the end of it all, we have a nice triangulated mesh of our point set built
from a quadtree.

The following pseudo code shows one means of implementing a quadtree which
handles only points. There are other approaches available.

It is assumed these structures are used.

    
    
    _// Simple coordinate object to represent points and vectors_
    **struct** XY
    {
        **float** x;
        **float** y;
    
        **function** __construct(_float_ _x, _float_ _y) {...}
    }
    
    _// Axis-aligned bounding box with half dimension and center_
    **struct** AABB
    {
        **XY** center;
        **float** halfDimension;
    
        **function** __construct(**XY** _center, **float** _halfDimension) {...}
        **function** containsPoint(**XY** point) {...}
        **function** intersectsAABB(**AABB** other) {...}
    }
    

This class represents both one quad tree and the node where it is rooted.

    
    
    **class** QuadTree
    {
        _// Arbitrary constant to indicate how many elements can be stored in this quad tree node_
        **constant int** QT_NODE_CAPACITY = 4;
    
        _// Axis-aligned bounding box stored as a center with half-dimensions_
        _// to represent the boundaries of this quad tree_
        **AABB** boundary;
    
        _// Points in this quad tree node_
        **Array of XY [size = QT_NODE_CAPACITY]** points;
    
        _// Children_
        **QuadTree*** northWest;
        **QuadTree*** northEast;
        **QuadTree*** southWest;
        **QuadTree*** southEast;
    
        _// Methods_
        **function** __construct(_AABB_ _boundary) {...}
        **function** insert(_XY_ p) {...}
        **function** subdivide() {...} _// create four children that fully divide this quad into four quads of equal area_
        **function** queryRange(_AABB_ range) {...}
    }
    

The following method inserts a point into the appropriate quad of a quadtree,
splitting if necessary.

    
    
    **class** QuadTree
    {
        ...
      
        _// Insert a point into the QuadTree_
        **function** insert(_XY_ p)
        {
            _// Ignore objects that do not belong in this quad tree_
            **if** (!boundary.containsPoint(p))
                **return** _false_ ; _// object cannot be added_
        
            _// If there is space in this quad tree and if doesn't have subdivisions, add the object here_
            **if** (points.size < QT_NODE_CAPACITY && northWest == _null_)
            {
                points.append(p);
                **return** _true_ ;
            }
        
            _// Otherwise, subdivide and then add the point to whichever node will accept it_
            **if** (northWest == _null_)
                subdivide();
            _// We have to add the points/data contained in this quad array to the new quads if we only want_
            _// the last node to hold the data_
        
            **if** (northWest->insert(p)) **return** _true_ ;
            **if** (northEast->insert(p)) **return** _true_ ;
            **if** (southWest->insert(p)) **return** _true_ ;
            **if** (southEast->insert(p)) **return** _true_ ;
        
            _// Otherwise, the point cannot be inserted for some unknown reason (this should never happen)_
            **return** _false_ ;
        }
    }
    

The following method finds all points contained within a range.

    
    
    **class** QuadTree
    {
        ...
      
        _// Find all points that appear within a range_
        **function** queryRange(_AABB_ range)
        {
            _// Prepare an array of results_
            _Array of XY_ pointsInRange;
        
            _// Automatically abort if the range does not intersect this quad_
            **if** (!boundary.intersectsAABB(range))
                **return** pointsInRange; _// empty list_
        
            _// Check objects at this quad level_
            **for** (**int** p = 0; p < points.size; p++)
            {
                **if** (range.containsPoint(points[p]))
                    pointsInRange.append(points[p]);
            }
        
            _// Terminate here, if there are no children_
            **if** (northWest == _null_)
                **return** pointsInRange;
        
            _// Otherwise, add the points from the children_
            pointsInRange.appendArray(northWest->queryRange(range));
            pointsInRange.appendArray(northEast->queryRange(range));
            pointsInRange.appendArray(southWest->queryRange(range));
            pointsInRange.appendArray(southEast->queryRange(range));
        
            **return** pointsInRange;
        }
    }
    

Surveys by Aluru  [  4  ]  and Samet  [  22  ]  [  16  ]  give a nice overview
of quadtrees.

  1. ** ^  ** Finkel, R. A.; Bentley, J. L. (1974). [ "Quad trees a data structure for retrieval on composite keys" ](https://www.researchgate.net/publication/220197855) . _Acta Informatica_ . **4** (1): 1–9. [ doi ](/wiki/Doi_\(identifier\) "Doi \(identifier\)") : [ 10.1007/BF00288933 ](https://doi.org/10.1007%2FBF00288933) . [ S2CID ](/wiki/S2CID_\(identifier\) "S2CID \(identifier\)") [ 33019699 ](https://api.semanticscholar.org/CorpusID:33019699) . Retrieved  6 November  2019  . 
  2. ** ^  ** Milan Sonka, Vaclav Hlavac, Roger Boyle. [ "Image Processing, Analysis, and Machine Vision" ](https://books.google.com/books?id=DcETCgAAQBAJ) . 2014\. p. 108-109. 
  3. ** ^  ** Finkel, R. A.; Bentley, J. L. (1974). "Quad Trees A Data Structure for Retrieval on Composite Keys". _Acta Informatica_ . **4** . Springer-Verlag: 1–9. [ doi ](/wiki/Doi_\(identifier\) "Doi \(identifier\)") : [ 10.1007/bf00288933 ](https://doi.org/10.1007%2Fbf00288933) . [ S2CID ](/wiki/S2CID_\(identifier\) "S2CID \(identifier\)") [ 33019699 ](https://api.semanticscholar.org/CorpusID:33019699) . 
  4. ^  _**a** _ _**b** _ _**c** _ _**d** _ _**e** _ _**f** _ Aluru, S. (2004). "Quadtrees and octrees". In D. Mehta and S. Sahni (ed.). _Handbook of Data Structures and Applications_ . Chapman and Hall/CRC. pp. 19-1 -- 19-26. [ ISBN ](/wiki/ISBN_\(identifier\) "ISBN \(identifier\)") [ 9781584884354  ](/wiki/Special:BookSources/9781584884354 "Special:BookSources/9781584884354") . 
  5. ** ^  ** Orenstein, J. A. (1982). "Multidimensional tries used for associative searching". _Information Processing Letters_ . **14** (4). Elsevier: 150–157. [ doi ](/wiki/Doi_\(identifier\) "Doi \(identifier\)") : [ 10.1016/0020-0190(82)90027-8 ](https://doi.org/10.1016%2F0020-0190%2882%2990027-8) . 
  6. ** ^  ** Samet, H. (1984). [ "The quadtree and related hierarchical data structures" ](http://www.cs.umd.edu/~hjs/pubs/SameCSUR84-ocr.pdf) (PDF)  . _ACM Computing Surveys_ . **16** (2). ACM: 187–260. [ doi ](/wiki/Doi_\(identifier\) "Doi \(identifier\)") : [ 10.1145/356924.356930 ](https://doi.org/10.1145%2F356924.356930) . [ S2CID ](/wiki/S2CID_\(identifier\) "S2CID \(identifier\)") [ 10319214 ](https://api.semanticscholar.org/CorpusID:10319214) . 
  7. ** ^  ** Warnock, J. E. (1969). "A hidden surface algorithm for computer generated halftone pictures". _Computer Science Department, University of Utah_ . TR 4-15. 
  8. ** ^  ** Schneier, M. (1981). "Two hierarchical linear feature representations: edge pyramids and edge quadtrees". _Computer Graphics and Image Processing_ . **17** (3). Elsevier: 211–224. [ doi ](/wiki/Doi_\(identifier\) "Doi \(identifier\)") : [ 10.1016/0146-664X(81)90002-2 ](https://doi.org/10.1016%2F0146-664X%2881%2990002-2) . 
  9. ** ^  ** [ Hanan Samet ](/wiki/Hanan_Samet "Hanan Samet") and Robert Webber. "Storing a Collection of Polygons Using Quadtrees". _ACM Transactions on Graphics_ July 1985: 182-222. _InfoLAB_ . Web. 23 March 2012 
  10. ** ^  ** Nelson, R. C.; Samet, H. (1986). [ "A consistent hierarchical representation for vector data" ](https://doi.org/10.1145%2F15886.15908) . _ACM SIGGRAPH Computer Graphics_ . **20** (4): 197–206. [ doi ](/wiki/Doi_\(identifier\) "Doi \(identifier\)") :  [ 10.1145/15886.15908 ](https://doi.org/10.1145%2F15886.15908) . 
  11. ** ^  ** [ Har-Peled, S. ](/wiki/Sariel_Har-Peled "Sariel Har-Peled") (2011). "Quadtrees - Hierarchical Grids". _Geometric approximation algorithms_ . Mathematical Surveys and Monographs Vol. 173, American mathematical society. 
  12. ** ^  ** Wanta, Damian; Smolik, Waldemar T.; Kryszyn, Jacek; Wróblewski, Przemysław; Midura, Mateusz (2021). [ "A Finite Volume Method using a Quadtree Non-Uniform Structured Mesh for Modeling in Electrical Capacitance Tomography" ](https://doi.org/10.1007%2Fs40010-021-00748-7) . _Proceedings of the National Academy of Sciences, India Section A_ . **92** (3): 443–452. [ doi ](/wiki/Doi_\(identifier\) "Doi \(identifier\)") :  [ 10.1007/s40010-021-00748-7 ](https://doi.org/10.1007%2Fs40010-021-00748-7) . [ S2CID ](/wiki/S2CID_\(identifier\) "S2CID \(identifier\)") [ 244224810 ](https://api.semanticscholar.org/CorpusID:244224810) . 
  13. ** ^  ** Sestoft, Peter (2014). _Spreadsheet Implementation Technology: Basics and Extensions_ . The MIT Press. pp. 60–63. [ ISBN ](/wiki/ISBN_\(identifier\) "ISBN \(identifier\)") [ 9780262526647  ](/wiki/Special:BookSources/9780262526647 "Special:BookSources/9780262526647") . 
  14. ** ^  ** Tomas G. Rokicki (2006-04-01). [ "An Algorithm for Compressing Space and Time" ](http://www.ddj.com/hpc-high-performance-computing/184406478) . Retrieved  2009-05-20  . 
  15. ** ^  ** Henning Eberhardt, Vesa Klumpp, Uwe D. Hanebeck, _Density Trees for Efficient Nonlinear State Estimation_ , Proceedings of the 13th International Conference on Information Fusion, Edinburgh, United Kingdom, July, 2010. 
  16. ^  _**a** _ _**b** _ Samet, H. (1989). "Hierarchical spatial data structures". _Symposium on Large Spatial Databases_ : 191–212. 
  17. ** ^  ** Hunter, G. M. (1978). _Efficient Computation and Data Structures for Graphics_ . Ph.D. dissertation, Department of Electrical Engineering and Computer Science, Princeton University. 
  18. ** ^  ** Hunter, G. M.; Steiglitz, K. (1979). "Operations on images using quad trees". _IEEE Transactions on Pattern Analysis and Machine Intelligence_ . **2** (2): 145–153. [ doi ](/wiki/Doi_\(identifier\) "Doi \(identifier\)") : [ 10.1109/tpami.1979.4766900 ](https://doi.org/10.1109%2Ftpami.1979.4766900) . [ PMID ](/wiki/PMID_\(identifier\) "PMID \(identifier\)") [ 21868843 ](https://pubmed.ncbi.nlm.nih.gov/21868843) . [ S2CID ](/wiki/S2CID_\(identifier\) "S2CID \(identifier\)") [ 2544535 ](https://api.semanticscholar.org/CorpusID:2544535) . 
  19. ** ^  ** Schneier, M. (1981). "Calculations of geometric properties using quadtrees". _Computer Graphics and Image Processing_ . **16** (3): 296–302. [ doi ](/wiki/Doi_\(identifier\) "Doi \(identifier\)") : [ 10.1016/0146-664X(81)90042-3 ](https://doi.org/10.1016%2F0146-664X%2881%2990042-3) . 
  20. ** ^  ** Mehta, Dinesh (2007). _Handbook of Data Structures and Applications_ . Chapman and Hall/CRC Press. p. 397. 
  21. ** ^  ** [ Samet, H. ](/wiki/Hanan_Samet "Hanan Samet") (1981). "Connected component labeling using quadtrees". _Journal of the ACM_ . **28** (3): 487–501. [ CiteSeerX ](/wiki/CiteSeerX_\(identifier\) "CiteSeerX \(identifier\)") [ 10.1.1.77.2573 ](https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.77.2573) . [ doi ](/wiki/Doi_\(identifier\) "Doi \(identifier\)") : [ 10.1145/322261.322267 ](https://doi.org/10.1145%2F322261.322267) . [ S2CID ](/wiki/S2CID_\(identifier\) "S2CID \(identifier\)") [ 17485118 ](https://api.semanticscholar.org/CorpusID:17485118) . 
  22. ^  _**a** _ _**b** _ Samet, H. (1988). "An overview of quadtrees, octrees, and related hierarchical data structures". In Earnshaw, R. A. (ed.). _Theoretical Foundations of Computer Graphics and CAD_ . Springer-Verlag. pp. 51–68. 
  23. ** ^  ** Tarjan, R. E. (1975). [ "Efficiency of a good but not linear set union algorithm" ](http://www.csd.uwo.ca/~eschost/Teaching/07-08/CS445a/p215-tarjan.pdf) (PDF)  . _Journal of the ACM_ . **22** (2): 215–225. [ doi ](/wiki/Doi_\(identifier\) "Doi \(identifier\)") : [ 10.1145/321879.321884 ](https://doi.org/10.1145%2F321879.321884) . [ hdl ](/wiki/Hdl_\(identifier\) "Hdl \(identifier\)") :  [ 1813/5942 ](https://hdl.handle.net/1813%2F5942) . [ S2CID ](/wiki/S2CID_\(identifier\) "S2CID \(identifier\)") [ 11105749 ](https://api.semanticscholar.org/CorpusID:11105749) . 
  24. ^  _**a** _ _**b** _ Har-Peled, S. (2011). "Good Triangulations and Meshing". _Geometric approximation algorithms_ . Mathematical Surveys and Monographs Vol. 173, American mathematical society. 
  25. ** ^  ** de Berg, M.; Cheong, O.; van Kreveld, M.; Overmars, M. H. (2008). "Quadtrees Non-Uniform Mesh Generation". _Computational Geometry Algorithms and Applications_ (3rd ed.). Springer-Verlag. 

  1. [ Raphael Finkel ](/wiki/Raphael_Finkel "Raphael Finkel") and [ J.L. Bentley ](/wiki/J.L._Bentley "J.L. Bentley") (1974). "Quad Trees: A Data Structure for Retrieval on Composite Keys". _Acta Informatica_ . **4** (1): 1–9. [ doi ](/wiki/Doi_\(identifier\) "Doi \(identifier\)") : [ 10.1007/BF00288933 ](https://doi.org/10.1007%2FBF00288933) . [ S2CID ](/wiki/S2CID_\(identifier\) "S2CID \(identifier\)") [ 33019699 ](https://api.semanticscholar.org/CorpusID:33019699) . 
  2. [ Mark de Berg ](/wiki/Mark_de_Berg "Mark de Berg") , [ Marc van Kreveld ](/wiki/Marc_van_Kreveld "Marc van Kreveld") , [ Mark Overmars ](/wiki/Mark_Overmars "Mark Overmars") , and [ Otfried Schwarzkopf ](/wiki/Otfried_Schwarzkopf "Otfried Schwarzkopf") (2000).  [ _Computational Geometry_ ](https://archive.org/details/computationalgeo00berg) (2nd revised ed.). [ Springer-Verlag ](/wiki/Springer-Verlag "Springer-Verlag") . [ ISBN ](/wiki/ISBN_\(identifier\) "ISBN \(identifier\)") [ 3-540-65620-0  ](/wiki/Special:BookSources/3-540-65620-0 "Special:BookSources/3-540-65620-0") .  ` {{ [ cite book ](/wiki/Template:Cite_book "Template:Cite book") }} ` : CS1 maint: multiple names: authors list ( [ link ](/wiki/Category:CS1_maint:_multiple_names:_authors_list "Category:CS1 maint: multiple names: authors list") )  Chapter 14: Quadtrees: pp. 291–306. 
  3. [ Samet, Hanan ](/wiki/Hanan_Samet "Hanan Samet") ; Webber, Robert (July 1985). [ "Storing a Collection of Polygons Using Quadtrees" ](http://infolab.usc.edu/csci585/Spring2008/den_ar/p182-samet.pdf) (PDF)  . Retrieved  23 March  2012  . 


-->

<!--






-->

<!--
* * *

###  쿼드 트리 (Quadtree)

* * *

쿼드 트리는 트리 구조의 데이터로, **2차원 공간을 4개의 동일한 구역으로 재귀적으로 세분화하여 분할** 한다.  
각 내부 노드에 4개의 자식이 있다.

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_2.png) _쿼드
트리의 모습_

참고

  * 이진 트리는 자식 노드가 2개 
  * 쿼드 트리는 자식 노드가 4개 
  * 옥트리는 자식 노드가 8개 

쿼드 트리는 데이터베이스 검색에 사용되기도 하며,  
2차원 공간을 4분할하여 효율적인 데이터 탐색을 진행한다.  
(넓은 지역에 대한 데이터베이스 구축에 매우 용이하다)

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_1_1.png) _데이터
베이스에서의 쿼드 트리_

하지만 일반적으로는 쿼드 트리는 일반적으로 지형(Terrain)에 사용된다.

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_4.png)
_지형(Terrain)에서의 쿼드 트리 컬링_

매우 거대한 지형을 빠르게 검색할 수 있고,  
큰 덩어리로 큼직하게 검색하고 찾아나가기 때문에 부하를 줄일 수 있다

* * *

###  쿼드트리 개요와 동작 원리

* * *

####  개요

* * *

쿼드 트리 : 2차원 평면을 공간 분할하는 용도

  * 점(Point) 쿼드트리: 2차원 평면에서 가까운 위치를 효과적으로 찾는 데 사용 (지도, 도시) 
  * **범위(Range) 쿼드트리** : 2차원 평면에서 영역을 가진 물체끼리 겹치는지 탐색하는 데 사용 

게임에서는 주로 범위 쿼드트리를 사용한다.

플랫포머 게임에서의 충돌 처리, 탑다운 뷰에서의 충돌 처리 등 2D 평면 공간에서 객체의 충돌 처리를 감지한다. (또는 위의 예시처럼 컬링에
사용되기도 한다)

충돌 처리는 주로 AABB 알고리즘을 이용하는데, 여기에 쿼드트리를 적용하면 효과적이다.  
한 물체에 대한 충돌 처리를 모든 객체와 일일이 비교해야 하는데 그러지 않아도 되고  
충돌 가능성이 있는 객체만 효과적으로 걸러낸다

####  동작 원리

* * *

  1. 쿼드 트리의 모든 노드는 고유한 사각형 AABB 영역과 객체 목록을 가진다 
  2. 전체 영역을 감싸는 사각형 AABB 영역을 생성하고 루트 노드로 지정 
  3. 자식으로 내려갈수록 4개의 자식을 가진 완전 트리 형태를 유지 
  4. **객체 삽입** : AABB 영역을 가진 객체를 노드의 객체 목록에 추가 

규칙 : 삽입할 물체를 살펴보고 필요하면 분할을 수행한다

  * 분할하는 경우는 삽입할 물체가 4분할 영역 중 하나에 _완전히 포함되어 있을 경우_
  * _경계선에 걸쳐있다면_ , 루트 목록에 추가하고 삽입 종료 

이렇게 트리 구조의 깊이를 늘려가면서 분할을 진행하는데 깊이를 너무 많이 설정하면 안 되기 때문에 **깊이 제한** 을 걸어둔다

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_7.png) _1\.
게임 맵을 포함하는 거대 정사각형 영역에 물체를 배치하는 경우 루트 노드는 전체 정사각형 영역이 된다_

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_8.png) _2\. 첫
번째 물체의 배치. 루트 노드와 4분할된 자식 노드 영역 중 하나에 완전히 포함되는지 검사한다_

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_9.png) _3\.
분할된 노드 영역에 포함되면 재귀적으로 검사를 반복한다_

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_10.png) _4\.
분할된 영역에 완전히 포함되지 못하는 경우, 분할을 멈추고 포함하는 영역의 객체 목록에 추가  
이러한 과정으로 객체 삽입이 종료된다. _

  

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_11.png) _참고 :
2번 객체를 배치한 예시 (루트 노드에서 바로 경계선에 걸리는 경우) - Root 노드에 객체를 추가한다_

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_12.png) _참고 :
10개의 객체를 배치한 예시_

  1. **충돌 질의** : 노드의 객체 목록에서 주어진 AABB 영역과 충돌하는 객체를 빠르게 파악 

주어진 AABB 영역이 쿼드트리 내 객체와 충돌하는지 파악하는 기능으로  
_질의할 AABB 영역이 속한 사분면 노드를 모두 파악_ 한다  
각 사분면 노드의 객체 목록에서 충돌을 가능 여부를 검색한다

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_13.png) _붉은
영역의 AABB 영역과 충돌하는 객체를 탐색_

붉은 영역이 3, 7, 8 객체와 충돌하고 있다  
이 붉은 영역과 충돌하는 물체를 탐색하기 위해서는 10개의 객체를 모두 전수조사 해야 한다.  
하지만 이 수가 많아지면 성능 저하가 발생하므로 트리구조를 활용해서 검색량을 줄인다.  
(검색 가능성이 있는 노드만을 걸러내는 작업을 실행한다)

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_14.png) _Root
영역_

만약 다음과 같이 루트 노드의 객체 목록에 물체가 있다면 (가정)  
루트노드의 객체 목록은 충돌 가능성이 있기 때문에 검사 목록에 추가한다

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_15.png)
_Upper Right 영역_

깊이 1의 UpperRight 영역에 물체가 다음과 같이 있다면 (가정)  
이또한 충돌 가능성이 있기 때문에 검사 목록에 추가한다

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_17.png)
_Upper Right 영역 내 LowerRight 영역_

깊이 2의 Upper Right 영역 내 LowerRight 영역에 다음과 같이 물체가 있다면  
…

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_18.png)
_Upper Right 영역 내 LowerRight 영역 내 하위 4개의 사분면_

깊이 3에서는 4개의 사분면 모두 충돌 가능성이 있으므로 모두 검사 목록에 추가한다  
여기서 트리 구조의 깊이를 최대 3으로 제한해, 조사를 종료한다

![](https://joonyle99.github.io/assets/images/algorithm_quadtree_19.png) _붉은
영역에 대한 충돌을 감지하기 위해 조사해야 할 총 노드_

깊이가 3이라면 85(1 + 4 + 16 + 64)개 노드가 생성되는데, 그 중 7개의 노드만을 감지하면 된다  
충돌 검사의 효율성이 크게 증가한다

객체의 삽입은 완전히 포함되는 경우에만 추가하면 됐다면,  
충돌 질의를 수행하는 경우에는 삽입과 다르게 _겹치는 영역과 포함하는 영역의 노드를 모두 추가_ 해야 한다

###  쿼드 트리의 구현

* * *

…


-->

<!--






-->

<!--
#include  < stdio.h  >

#include  < malloc  .h  >

#include  < memory.h  >

void  quadTree(  char  *  *  data,  int  beginX,  int  beginY,  int  size  )

{

// 병합 가능한지 체크---------------------------------

char  beginData  =  data[beginY][beginX];

bool  isCombinable  =  true  ;

for  (  int  y  =  beginY; y  < beginY  \+  size  ;  \+  \+  y) {

for  (  int  x  =  beginX; x  < beginX  \+  size  ;  \+  \+  x) {

if  (beginData  !  =  data[y][x])

{

isCombinable  =  false  ;

break  ;

}

}

if  (isCombinable  =  =  false  )

break  ;

}

//---------------------------------------------------

// 병합이 가능하면------------------------------------

if  (isCombinable)

{

printf  (  "%c"  , beginData);

return  ;

}

// 그게 아니라면 4개로 분할---------------------------

int  halfSize  =  (  int  )(  size  *  0\.  5f);

printf  (  "("  );

quadTree(data, beginX, beginY, halfSize);

quadTree(data, beginX  \+  halfSize, beginY, halfSize);

quadTree(data, beginX, beginY  \+  halfSize, halfSize);

quadTree(data, beginX  \+  halfSize, beginY  \+  halfSize, halfSize);

printf  (  ")"  );

}

void  main()

{

int  dataSize  =  0  ;

printf  (  "데이터의 크기를 입력해주세요(2의 승수):"  );

scanf  (  "%d"  ,  & dataSize);

// 메모리 할당

char  *  *  data  =  (  char  *  *  )  malloc  (  sizeof  (  char  *  )  *
dataSize);

for  (  int  i  =  0  ; i  < dataSize;  \+  \+  i)

{

data[i]  =  (  char  *  )  malloc  (  sizeof  (  char  )  *  (dataSize  \+  1
));

memset(data[i],  0  ,  sizeof  (data[i]));

}

printf  (  "데이터를 입력해주세요.\n"  );

for  (  int  i  =  0  ; i  < dataSize;  \+  \+  i)

{

scanf  (  "%s"  , data[i]);

}

// 분할

quadTree(data,  0  ,  0  , dataSize);

for  (  int  i  =  0  ; i  < dataSize;  \+  \+  i)

{

free  (data[i]);

}

free  (data);

}


-->

<!--






-->

