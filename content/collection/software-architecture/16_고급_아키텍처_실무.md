---
draft: true
---
# 16ì¥. ê³ ê¸‰ ì•„í‚¤í…ì²˜ ì‹¤ë¬´

## ğŸ“‹ í•™ìŠµ ëª©í‘œ
- ëŒ€ê·œëª¨ ì‹œìŠ¤í…œ ë¶„í•´ ì „ëµì„ ì´í•´í•œë‹¤
- ì•„í‚¤í…ì²˜ ì§„í™”ì™€ ë§ˆì´ê·¸ë ˆì´ì…˜ ë°©ë²•ì„ ìŠµë“í•œë‹¤
- ì„±ëŠ¥ ì—”ì§€ë‹ˆì–´ë§ ì ‘ê·¼ë²•ì„ í•™ìŠµí•œë‹¤
- ì•„í‚¤í…ì²˜ ìœ„í—˜ ê´€ë¦¬ ë°©ë²•ì„ íŒŒì•…í•œë‹¤

---

## 16.1 ëŒ€ê·œëª¨ ì‹œìŠ¤í…œ ë¶„í•´ ì „ëµ

### 16.1.1 Strangler Fig íŒ¨í„´

ëŒ€ê·œëª¨ ì‹œìŠ¤í…œì„ ë¶„í•´í•  ë•ŒëŠ” **ì ì§„ì ì´ê³  ìœ„í—˜ì„ ìµœì†Œí™”í•˜ëŠ” ì „ëµ**ì´ í•„ìš”í•©ë‹ˆë‹¤.

```java
// Strangler Fig íŒ¨í„´ êµ¬í˜„
@Component
public class StranglerFigProxy {
    
    private final LegacySystemClient legacyClient;
    private final NewServiceClient newServiceClient;
    private final FeatureToggleService featureToggle;
    
    public CustomerData getCustomer(String customerId) {
        if (featureToggle.isEnabled("new-customer-service", customerId)) {
            try {
                return newServiceClient.getCustomer(customerId);
            } catch (Exception e) {
                log.warn("ì‹ ê·œ ì„œë¹„ìŠ¤ ì‹¤íŒ¨, ë ˆê±°ì‹œë¡œ í´ë°±: {}", e.getMessage());
                return legacyClient.getCustomer(customerId);
            }
        } else {
            return legacyClient.getCustomer(customerId);
        }
    }
    
    public void updateCustomer(String customerId, CustomerUpdateRequest request) {
        if (featureToggle.isEnabled("new-customer-service", customerId)) {
            newServiceClient.updateCustomer(customerId, request);
        }
        
        legacyClient.updateCustomer(customerId, request);
        validateDataConsistency(customerId);
    }
    
    private void validateDataConsistency(String customerId) {
        CompletableFuture.runAsync(() -> {
            try {
                CustomerData legacyData = legacyClient.getCustomer(customerId);
                CustomerData newData = newServiceClient.getCustomer(customerId);
                
                if (!dataMatches(legacyData, newData)) {
                    alertService.sendAlert("ë°ì´í„° ë¶ˆì¼ì¹˜ ë°œê²¬: " + customerId);
                }
            } catch (Exception e) {
                log.error("ë°ì´í„° ê²€ì¦ ì‹¤íŒ¨: {}", customerId, e);
            }
        });
    }
}

// í”¼ì²˜ í† ê¸€ ì„œë¹„ìŠ¤
@Service
public class FeatureToggleService {
    
    private final RedisTemplate<String, String> redisTemplate;
    
    public boolean isEnabled(String feature, String context) {
        String key = "feature:" + feature;
        String config = redisTemplate.opsForValue().get(key);
        
        if (config == null) {
            return false;
        }
        
        FeatureConfig featureConfig = parseConfig(config);
        
        if (featureConfig.getRolloutPercentage() == 100) {
            return true;
        }
        
        int hash = Math.abs(context.hashCode()) % 100;
        return hash < featureConfig.getRolloutPercentage();
    }
}
```

### 16.1.2 ë„ë©”ì¸ ê¸°ë°˜ ë¶„í•´

```java
// ë„ë©”ì¸ ê²½ê³„ ì‹ë³„
@Component
public class DomainBoundaryAnalyzer {
    
    public List<DomainBoundary> analyzeBoundaries(SystemModel system) {
        List<DomainBoundary> boundaries = new ArrayList<>();
        
        Map<String, Set<String>> dataGroups = analyzeDataCohesion(system);
        Map<String, Set<String>> functionalGroups = analyzeFunctionalCohesion(system);
        
        for (String domain : dataGroups.keySet()) {
            DomainBoundary boundary = new DomainBoundary(domain);
            boundary.setDataEntities(dataGroups.get(domain));
            boundary.setFunctions(functionalGroups.get(domain));
            
            double cohesionScore = calculateCohesion(boundary);
            double couplingScore = calculateCoupling(boundary, system);
            boundary.setQualityScore(cohesionScore - couplingScore);
            
            boundaries.add(boundary);
        }
        
        return boundaries.stream()
            .sorted((b1, b2) -> Double.compare(b2.getQualityScore(), b1.getQualityScore()))
            .collect(Collectors.toList());
    }
}
```

---

## 16.2 ì•„í‚¤í…ì²˜ ì§„í™”

### 16.2.1 ì ì‘ì„± í•¨ìˆ˜ (Fitness Function)

```java
// ì ì‘ì„± í•¨ìˆ˜ êµ¬í˜„
@Component
public class ArchitectureFitnessFunction {
    
    public FitnessResult evaluateArchitecture(SystemArchitecture architecture) {
        FitnessResult result = new FitnessResult();
        
        double modularity = measureModularity(architecture);
        result.addMetric("modularity", modularity, 0.8);
        
        double coupling = measureCoupling(architecture);
        result.addMetric("coupling", coupling, 0.3);
        
        int cyclicDependencies = countCyclicDependencies(architecture);
        result.addMetric("cyclic_dependencies", cyclicDependencies, 0);
        
        double testCoverage = measureTestCoverage(architecture);
        result.addMetric("test_coverage", testCoverage, 0.8);
        
        return result;
    }
    
    @Scheduled(fixedRate = 3600000) // 1ì‹œê°„ë§ˆë‹¤ ì‹¤í–‰
    public void continuousArchitectureValidation() {
        SystemArchitecture currentArchitecture = architectureService.getCurrentArchitecture();
        FitnessResult result = evaluateArchitecture(currentArchitecture);
        
        for (FitnessMetric metric : result.getMetrics()) {
            if (!metric.meetsThreshold()) {
                alertService.sendArchitectureAlert(
                    String.format("ì•„í‚¤í…ì²˜ ì„ê³„ê°’ ìœ„ë°˜: %s = %f", 
                        metric.getName(), metric.getValue())
                );
            }
        }
        
        metricsRepository.save(new ArchitectureMetrics(LocalDateTime.now(), result));
    }
}
```

---

## 16.3 ì„±ëŠ¥ ì—”ì§€ë‹ˆì–´ë§

### 16.3.1 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```java
// ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
@Component
public class PerformanceMetricsCollector {
    
    private final MeterRegistry meterRegistry;
    
    @EventListener
    public void handleRequest(RequestEvent event) {
        Timer.Sample sample = Timer.start(meterRegistry);
        
        Timer requestTimer = Timer.builder("http.request.duration")
            .tag("method", event.getMethod())
            .tag("uri", event.getUri())
            .register(meterRegistry);
        
        sample.stop(requestTimer);
        
        Counter.builder("http.request.count")
            .tag("method", event.getMethod())
            .register(meterRegistry)
            .increment();
        
        if (event.getStatus() >= 400) {
            Counter.builder("http.request.errors")
                .tag("status", String.valueOf(event.getStatus()))
                .register(meterRegistry)
                .increment();
        }
    }
}

// ì„±ëŠ¥ ë³‘ëª© íƒì§€
@Service
public class PerformanceBottleneckDetector {
    
    @Scheduled(fixedRate = 60000) // 1ë¶„ë§ˆë‹¤ ì‹¤í–‰
    public void detectBottlenecks() {
        List<PerformanceBottleneck> bottlenecks = new ArrayList<>();
        
        bottlenecks.addAll(detectResponseTimeBottlenecks());
        bottlenecks.addAll(detectCpuBottlenecks());
        bottlenecks.addAll(detectMemoryBottlenecks());
        
        for (PerformanceBottleneck bottleneck : bottlenecks) {
            if (bottleneck.getSeverity() == Severity.CRITICAL) {
                alertService.sendCriticalAlert(bottleneck);
                autoOptimizer.tryAutoOptimization(bottleneck);
            }
        }
    }
    
    private List<PerformanceBottleneck> detectResponseTimeBottlenecks() {
        List<PerformanceBottleneck> bottlenecks = new ArrayList<>();
        Map<String, Double> p95ResponseTimes = metricsService.getP95ResponseTimes();
        
        for (Map.Entry<String, Double> entry : p95ResponseTimes.entrySet()) {
            String endpoint = entry.getKey();
            double p95Time = entry.getValue();
            double threshold = getThresholdForEndpoint(endpoint);
            
            if (p95Time > threshold) {
                bottlenecks.add(PerformanceBottleneck.builder()
                    .type(BottleneckType.RESPONSE_TIME)
                    .component(endpoint)
                    .severity(calculateSeverity(p95Time, threshold))
                    .build());
            }
        }
        
        return bottlenecks;
    }
}
```

---

## 16.4 ì•„í‚¤í…ì²˜ ìœ„í—˜ ê´€ë¦¬

### 16.4.1 ìœ„í—˜ í‰ê°€

```java
// ì•„í‚¤í…ì²˜ ìœ„í—˜ í‰ê°€
@Service
public class ArchitectureRiskAssessment {
    
    public RiskAssessmentReport assessRisks(SystemArchitecture architecture) {
        RiskAssessmentReport report = new RiskAssessmentReport();
        
        List<TechnicalRisk> technicalRisks = assessTechnicalRisks(architecture);
        report.addTechnicalRisks(technicalRisks);
        
        List<OperationalRisk> operationalRisks = assessOperationalRisks(architecture);
        report.addOperationalRisks(operationalRisks);
        
        List<SecurityRisk> securityRisks = assessSecurityRisks(architecture);
        report.addSecurityRisks(securityRisks);
        
        return report;
    }
    
    private List<TechnicalRisk> assessTechnicalRisks(SystemArchitecture architecture) {
        List<TechnicalRisk> risks = new ArrayList<>();
        
        // ë‹¨ì¼ ì¥ì• ì  íƒì§€
        List<Component> singlePoints = findSinglePointsOfFailure(architecture);
        for (Component component : singlePoints) {
            risks.add(TechnicalRisk.builder()
                .type(RiskType.SINGLE_POINT_OF_FAILURE)
                .component(component.getName())
                .probability(0.3)
                .impact(0.9)
                .description("ë‹¨ì¼ ì¥ì• ì ìœ¼ë¡œ ì¸í•œ ì „ì²´ ì‹œìŠ¤í…œ ì¥ì•  ê°€ëŠ¥ì„±")
                .build());
        }
        
        // ê¸°ìˆ  ë¶€ì±„ ìœ„í—˜
        double technicalDebtRatio = calculateTechnicalDebtRatio(architecture);
        if (technicalDebtRatio > 0.3) {
            risks.add(TechnicalRisk.builder()
                .type(RiskType.TECHNICAL_DEBT)
                .probability(0.8)
                .impact(0.6)
                .description(String.format("ë†’ì€ ê¸°ìˆ  ë¶€ì±„ ë¹„ìœ¨: %f", technicalDebtRatio))
                .build());
        }
        
        return risks;
    }
}

// ì§€ì†ì  ìœ„í—˜ ëª¨ë‹ˆí„°ë§
@Component
public class ContinuousRiskMonitoring {
    
    @Scheduled(cron = "0 0 2 * * ?") // ë§¤ì¼ ìƒˆë²½ 2ì‹œ ì‹¤í–‰
    public void dailyRiskAssessment() {
        SystemArchitecture currentArchitecture = architectureService.getCurrentArchitecture();
        RiskAssessmentReport report = riskAssessment.assessRisks(currentArchitecture);
        
        RiskAssessmentReport previousReport = getPreviousReport();
        RiskChangeAnalysis changeAnalysis = analyzeRiskChanges(previousReport, report);
        
        for (Risk newRisk : changeAnalysis.getNewRisks()) {
            alertService.sendRiskAlert("ìƒˆë¡œìš´ ìœ„í—˜ íƒì§€", newRisk);
        }
        
        for (Risk increasedRisk : changeAnalysis.getIncreasedRisks()) {
            alertService.sendRiskAlert("ìœ„í—˜ ìˆ˜ì¤€ ì¦ê°€", increasedRisk);
        }
        
        riskReportRepository.save(report);
        dashboardService.updateRiskDashboard(report);
    }
}
```

---

## ğŸ¯ í•µì‹¬ ìš”ì•½

### ê³ ê¸‰ ì•„í‚¤í…ì²˜ ì‹¤ë¬´ ì˜ì—­

| **ì˜ì—­** | **í•µì‹¬ ê¸°ë²•** | **ì£¼ìš” ë„êµ¬** | **ì„±ê³µ ìš”ì¸** |
|---------|-------------|-------------|-------------|
| **ì‹œìŠ¤í…œ ë¶„í•´** | Strangler Fig, ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜ | í”¼ì²˜ í† ê¸€, ë³‘ë ¬ ì‹¤í–‰ | ìœ„í—˜ ìµœì†Œí™” |
| **ì•„í‚¤í…ì²˜ ì§„í™”** | ì ì‘ì„± í•¨ìˆ˜, ë²„ì „ ì „ëµ | ì§€ì†ì  ëª¨ë‹ˆí„°ë§ | ìë™í™”ëœ ê²€ì¦ |
| **ì„±ëŠ¥ ì—”ì§€ë‹ˆì–´ë§** | ë©”íŠ¸ë¦­ ìˆ˜ì§‘, ë³‘ëª© íƒì§€ | APM ë„êµ¬, ìë™ ìµœì í™” | ë°ì´í„° ê¸°ë°˜ ê²°ì • |
| **ìœ„í—˜ ê´€ë¦¬** | ìœ„í—˜ í‰ê°€, ì™„í™” ì „ëµ | ëª¨ë‹ˆí„°ë§, ì•Œë¦¼ ì‹œìŠ¤í…œ | ì˜ˆë°©ì  ì ‘ê·¼ |

### ì‹¤ë¬´ ì ìš© ê°€ì´ë“œë¼ì¸
1. **ì ì§„ì  ë³€í™” (Incremental Change)**
2. **ì¸¡ì • ê°€ëŠ¥í•œ ëª©í‘œ (Measurable Goals)**
3. **ìë™í™”ëœ ê²€ì¦ (Automated Validation)**
4. **ì§€ì†ì  ëª¨ë‹ˆí„°ë§ (Continuous Monitoring)**

---

## ğŸ’­ ìƒê°í•´ë³´ê¸°

1. ë ˆê±°ì‹œ ì‹œìŠ¤í…œ ë¶„í•´ ì‹œ ê°€ì¥ í° ìœ„í—˜ ìš”ì†ŒëŠ” ë¬´ì—‡ì¸ê°€?
2. ì•„í‚¤í…ì²˜ ì§„í™”ì˜ ì„±ê³µì„ ì–´ë–»ê²Œ ì¸¡ì •í•  ê²ƒì¸ê°€?
3. ì„±ëŠ¥ ìµœì í™”ì™€ ê°œë°œ ìƒì‚°ì„± ì‚¬ì´ì˜ ê· í˜•ì ì€?

---

## ğŸ“š ì¶”ê°€ í•™ìŠµ ìë£Œ

### ë„ì„œ
- "Monolith to Microservices" - Sam Newman
- "Building Evolutionary Architectures" - Neal Ford

### ì˜¨ë¼ì¸ ìë£Œ
- Microservices.io íŒ¨í„´ ì¹´íƒˆë¡œê·¸
- Martin Fowler ë¸”ë¡œê·¸ 