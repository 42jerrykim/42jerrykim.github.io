---
draft: true
---
# 12ì¥. ë¶„ì‚° ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

## ğŸ“‹ í•™ìŠµ ëª©í‘œ
- CAP ì •ë¦¬ì™€ PACELC ì •ë¦¬ì˜ ê°œë…ì„ ì´í•´í•œë‹¤
- ë¶„ì‚° í•©ì˜ ì•Œê³ ë¦¬ì¦˜ì˜ ë™ì‘ ì›ë¦¬ë¥¼ íŒŒì•…í•œë‹¤
- ë¶„ì‚° íŠ¸ëœì­ì…˜ê³¼ Saga íŒ¨í„´ì„ ìŠµë“í•œë‹¤
- ìƒ¤ë”©ê³¼ íŒŒí‹°ì…”ë‹ ì „ëµì„ í•™ìŠµí•œë‹¤

---

## 12.1 ë¶„ì‚° ì‹œìŠ¤í…œ ì´ë¡ 

### 12.1.1 CAP ì •ë¦¬

CAP ì •ë¦¬ëŠ” ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œ **ì¼ê´€ì„±(Consistency), ê°€ìš©ì„±(Availability), ë¶„í•  í—ˆìš©ì„±(Partition Tolerance) ì¤‘ ìµœëŒ€ 2ê°œë§Œ ë™ì‹œì— ë³´ì¥í•  ìˆ˜ ìˆë‹¤**ëŠ” ì´ë¡ ì…ë‹ˆë‹¤.

```java
// CP ì‹œìŠ¤í…œ - ì¼ê´€ì„±ê³¼ ë¶„í•  í—ˆìš©ì„± ìš°ì„ 
@Service
public class ConsistentUserService {
    
    private final UserRepository primaryRepository;
    private final UserRepository replicaRepository;
    
    @Transactional
    public void updateUser(String userId, UserUpdateRequest request) {
        try {
            // ì£¼ ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸
            User user = primaryRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"));
            
            user.update(request);
            primaryRepository.save(user);
            
            // ë³µì œë³¸ ë™ê¸° ì—…ë°ì´íŠ¸ (ì¼ê´€ì„± ë³´ì¥)
            replicaRepository.save(user);
            
        } catch (Exception e) {
            // ë„¤íŠ¸ì›Œí¬ ë¶„í•  ì‹œ ì„œë¹„ìŠ¤ ì¤‘ë‹¨ (ê°€ìš©ì„± í¬ê¸°)
            throw new ServiceUnavailableException("ì¼ì‹œì ìœ¼ë¡œ ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
        }
    }
}

// AP ì‹œìŠ¤í…œ - ê°€ìš©ì„±ê³¼ ë¶„í•  í—ˆìš©ì„± ìš°ì„ 
@Service
public class AvailableUserService {
    
    private final List<UserRepository> repositories;
    private final EventPublisher eventPublisher;
    
    public void updateUser(String userId, UserUpdateRequest request) {
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        
        for (UserRepository repository : repositories) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                try {
                    User user = repository.findById(userId)
                        .orElseThrow(() -> new UserNotFoundException("ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"));
                    
                    user.update(request);
                    repository.save(user);
                    
                } catch (Exception e) {
                    // ê°œë³„ ë…¸ë“œ ì‹¤íŒ¨ëŠ” ë¬´ì‹œ (ê°€ìš©ì„± ìš°ì„ )
                    log.warn("ë…¸ë“œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {}", e.getMessage());
                }
            });
            
            futures.add(future);
        }
        
        // ìµœì†Œ í•˜ë‚˜ì˜ ë…¸ë“œì—ì„œ ì„±ê³µí•˜ë©´ OK
        CompletableFuture.anyOf(futures.toArray(new CompletableFuture[0]))
            .thenRun(() -> {
                // ìµœì¢… ì¼ê´€ì„±ì„ ìœ„í•œ ì´ë²¤íŠ¸ ë°œí–‰
                eventPublisher.publish(new UserUpdatedEvent(userId, request));
            });
    }
}
```

### 12.1.2 PACELC ì •ë¦¬

PACELC ì •ë¦¬ëŠ” **ë„¤íŠ¸ì›Œí¬ ë¶„í• (P)ì´ ë°œìƒí•˜ë©´ ê°€ìš©ì„±(A)ê³¼ ì¼ê´€ì„±(C) ì¤‘ ì„ íƒí•´ì•¼ í•˜ê³ , ì •ìƒ ìƒíƒœ(E)ì—ì„œëŠ” ì§€ì—°ì‹œê°„(L)ê³¼ ì¼ê´€ì„±(C) ì¤‘ ì„ íƒí•´ì•¼ í•œë‹¤**ëŠ” í™•ì¥ëœ ì´ë¡ ì…ë‹ˆë‹¤.

```java
// PA/EL ì‹œìŠ¤í…œ - ê°€ìš©ì„±ê³¼ ë‚®ì€ ì§€ì—°ì‹œê°„ ìš°ì„ 
@Service
public class EventuallyConsistentService {
    
    private final CacheManager cacheManager;
    private final MessageQueue messageQueue;
    
    public UserDto getUser(String userId) {
        // ìºì‹œì—ì„œ ë¨¼ì € ì¡°íšŒ (ë‚®ì€ ì§€ì—°ì‹œê°„)
        UserDto cachedUser = cacheManager.get(userId);
        if (cachedUser != null) {
            return cachedUser;
        }
        
        // ìºì‹œ ë¯¸ìŠ¤ì‹œ ë¹„ë™ê¸°ë¡œ ë°ì´í„° ë¡œë“œ
        CompletableFuture.runAsync(() -> {
            UserDto user = loadUserFromDatabase(userId);
            cacheManager.put(userId, user);
        });
        
        // ì„ì‹œ ë°ì´í„° ë°˜í™˜ (ê°€ìš©ì„± ìš°ì„ )
        return UserDto.createTemporary(userId);
    }
    
    public void updateUser(String userId, UserUpdateRequest request) {
        // ë¹„ë™ê¸° ì²˜ë¦¬ë¡œ ë¹ ë¥¸ ì‘ë‹µ (ë‚®ì€ ì§€ì—°ì‹œê°„)
        messageQueue.send(new UserUpdateMessage(userId, request));
        
        // ìºì‹œ ë¬´íš¨í™”
        cacheManager.evict(userId);
    }
}

// PC/EC ì‹œìŠ¤í…œ - ì¼ê´€ì„± ìš°ì„ 
@Service
public class StrongConsistentService {
    
    private final DistributedLock distributedLock;
    private final List<DatabaseNode> databaseNodes;
    
    public void updateUser(String userId, UserUpdateRequest request) {
        String lockKey = "user:" + userId;
        
        // ë¶„ì‚° ë½ íšë“ (ì¼ê´€ì„± ë³´ì¥)
        try (Lock lock = distributedLock.acquire(lockKey)) {
            
            // ëª¨ë“  ë…¸ë“œì—ì„œ ë™ê¸°ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸
            List<CompletableFuture<Void>> futures = databaseNodes.stream()
                .map(node -> CompletableFuture.runAsync(() -> 
                    node.updateUser(userId, request)))
                .collect(Collectors.toList());
            
            // ëª¨ë“  ë…¸ë“œ ì—…ë°ì´íŠ¸ ì™„ë£Œ ëŒ€ê¸° (ë†’ì€ ì§€ì—°ì‹œê°„ ê°ìˆ˜)
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .get(5, TimeUnit.SECONDS);
                
        } catch (Exception e) {
            throw new ConsistencyException("ì¼ê´€ì„±ì„ ë³´ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤", e);
        }
    }
}
```

---

## 12.2 ë¶„ì‚° í•©ì˜ ì•Œê³ ë¦¬ì¦˜

### 12.2.1 Raft ì•Œê³ ë¦¬ì¦˜

RaftëŠ” **ë¦¬ë” ê¸°ë°˜ì˜ ë¶„ì‚° í•©ì˜ ì•Œê³ ë¦¬ì¦˜**ìœ¼ë¡œ ì´í•´í•˜ê¸° ì‰½ê³  êµ¬í˜„í•˜ê¸° ê°„ë‹¨í•©ë‹ˆë‹¤.

```java
// Raft ë…¸ë“œ êµ¬í˜„
public class RaftNode {
    
    private NodeState state = NodeState.FOLLOWER;
    private String currentLeader;
    private int currentTerm = 0;
    private String votedFor;
    private List<LogEntry> log = new ArrayList<>();
    private int commitIndex = 0;
    
    private final List<String> peers;
    private final String nodeId;
    
    public RaftNode(String nodeId, List<String> peers) {
        this.nodeId = nodeId;
        this.peers = peers;
    }
    
    // ë¦¬ë” ì„ ì¶œ
    public void startElection() {
        state = NodeState.CANDIDATE;
        currentTerm++;
        votedFor = nodeId;
        
        int votes = 1; // ìì‹ ì—ê²Œ íˆ¬í‘œ
        
        for (String peer : peers) {
            RequestVoteResponse response = sendRequestVote(peer);
            if (response.isVoteGranted()) {
                votes++;
            }
        }
        
        if (votes > peers.size() / 2) {
            becomeLeader();
        } else {
            state = NodeState.FOLLOWER;
        }
    }
    
    private void becomeLeader() {
        state = NodeState.LEADER;
        currentLeader = nodeId;
        
        // í•˜íŠ¸ë¹„íŠ¸ ì „ì†¡ ì‹œì‘
        startHeartbeat();
    }
    
    // ë¡œê·¸ ë³µì œ
    public boolean appendEntry(LogEntry entry) {
        if (state != NodeState.LEADER) {
            return false;
        }
        
        log.add(entry);
        
        // íŒ”ë¡œì›Œë“¤ì—ê²Œ ë¡œê·¸ ë³µì œ
        int successCount = 1; // ë¦¬ë” ìì‹ 
        
        for (String peer : peers) {
            AppendEntriesResponse response = sendAppendEntries(peer, entry);
            if (response.isSuccess()) {
                successCount++;
            }
        }
        
        // ê³¼ë°˜ìˆ˜ í•©ì˜ ë‹¬ì„±ì‹œ ì»¤ë°‹
        if (successCount > peers.size() / 2) {
            commitIndex = log.size() - 1;
            return true;
        }
        
        return false;
    }
    
    // íˆ¬í‘œ ìš”ì²­ ì²˜ë¦¬
    public RequestVoteResponse handleRequestVote(RequestVoteRequest request) {
        if (request.getTerm() < currentTerm) {
            return new RequestVoteResponse(currentTerm, false);
        }
        
        if (request.getTerm() > currentTerm) {
            currentTerm = request.getTerm();
            votedFor = null;
            state = NodeState.FOLLOWER;
        }
        
        if (votedFor == null || votedFor.equals(request.getCandidateId())) {
            votedFor = request.getCandidateId();
            return new RequestVoteResponse(currentTerm, true);
        }
        
        return new RequestVoteResponse(currentTerm, false);
    }
    
    // ë¡œê·¸ ì¶”ê°€ ìš”ì²­ ì²˜ë¦¬
    public AppendEntriesResponse handleAppendEntries(AppendEntriesRequest request) {
        if (request.getTerm() < currentTerm) {
            return new AppendEntriesResponse(currentTerm, false);
        }
        
        currentTerm = request.getTerm();
        currentLeader = request.getLeaderId();
        state = NodeState.FOLLOWER;
        
        // ë¡œê·¸ ì¼ì¹˜ì„± ê²€ì‚¬
        if (request.getPrevLogIndex() >= 0 && 
            (log.size() <= request.getPrevLogIndex() || 
             !log.get(request.getPrevLogIndex()).getTerm().equals(request.getPrevLogTerm()))) {
            return new AppendEntriesResponse(currentTerm, false);
        }
        
        // ë¡œê·¸ ì¶”ê°€
        if (request.getEntries() != null && !request.getEntries().isEmpty()) {
            log.addAll(request.getEntries());
        }
        
        // ì»¤ë°‹ ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸
        if (request.getLeaderCommit() > commitIndex) {
            commitIndex = Math.min(request.getLeaderCommit(), log.size() - 1);
        }
        
        return new AppendEntriesResponse(currentTerm, true);
    }
}

enum NodeState {
    FOLLOWER, CANDIDATE, LEADER
}

// ë¡œê·¸ ì—”íŠ¸ë¦¬
public class LogEntry {
    private final int term;
    private final String command;
    private final LocalDateTime timestamp;
    
    public LogEntry(int term, String command) {
        this.term = term;
        this.command = command;
        this.timestamp = LocalDateTime.now();
    }
}
```

---

## 12.3 ë¶„ì‚° íŠ¸ëœì­ì…˜

### 12.3.1 2ë‹¨ê³„ ì»¤ë°‹ (2PC)

```java
// 2ë‹¨ê³„ ì»¤ë°‹ ì½”ë””ë„¤ì´í„°
@Service
public class TwoPhaseCommitCoordinator {
    
    private final List<TransactionParticipant> participants;
    
    public void executeDistributedTransaction(DistributedTransaction transaction) {
        String transactionId = UUID.randomUUID().toString();
        
        try {
            // Phase 1: Prepare
            boolean allPrepared = preparePhase(transactionId, transaction);
            
            if (allPrepared) {
                // Phase 2: Commit
                commitPhase(transactionId);
            } else {
                // Phase 2: Abort
                abortPhase(transactionId);
                throw new TransactionAbortedException("íŠ¸ëœì­ì…˜ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤");
            }
            
        } catch (Exception e) {
            abortPhase(transactionId);
            throw new DistributedTransactionException("ë¶„ì‚° íŠ¸ëœì­ì…˜ ì‹¤í–‰ ì‹¤íŒ¨", e);
        }
    }
    
    private boolean preparePhase(String transactionId, DistributedTransaction transaction) {
        List<CompletableFuture<Boolean>> prepareFutures = new ArrayList<>();
        
        for (TransactionParticipant participant : participants) {
            CompletableFuture<Boolean> future = CompletableFuture.supplyAsync(() -> {
                try {
                    return participant.prepare(transactionId, transaction.getOperationFor(participant));
                } catch (Exception e) {
                    log.error("ì°¸ì—¬ì ì¤€ë¹„ ì‹¤íŒ¨: {}", participant.getId(), e);
                    return false;
                }
            });
            
            prepareFutures.add(future);
        }
        
        // ëª¨ë“  ì°¸ì—¬ìì˜ ì¤€ë¹„ ì™„ë£Œ ëŒ€ê¸°
        return prepareFutures.stream()
            .map(CompletableFuture::join)
            .allMatch(prepared -> prepared);
    }
    
    private void commitPhase(String transactionId) {
        List<CompletableFuture<Void>> commitFutures = participants.stream()
            .map(participant -> CompletableFuture.runAsync(() -> 
                participant.commit(transactionId)))
            .collect(Collectors.toList());
        
        CompletableFuture.allOf(commitFutures.toArray(new CompletableFuture[0])).join();
    }
    
    private void abortPhase(String transactionId) {
        List<CompletableFuture<Void>> abortFutures = participants.stream()
            .map(participant -> CompletableFuture.runAsync(() -> 
                participant.abort(transactionId)))
            .collect(Collectors.toList());
        
        CompletableFuture.allOf(abortFutures.toArray(new CompletableFuture[0])).join();
    }
}

// íŠ¸ëœì­ì…˜ ì°¸ì—¬ì
public interface TransactionParticipant {
    String getId();
    boolean prepare(String transactionId, TransactionOperation operation);
    void commit(String transactionId);
    void abort(String transactionId);
}

@Component
public class DatabaseTransactionParticipant implements TransactionParticipant {
    
    private final DataSource dataSource;
    private final Map<String, Connection> preparedConnections = new ConcurrentHashMap<>();
    
    @Override
    public boolean prepare(String transactionId, TransactionOperation operation) {
        try {
            Connection connection = dataSource.getConnection();
            connection.setAutoCommit(false);
            
            // íŠ¸ëœì­ì…˜ ì‹¤í–‰
            operation.execute(connection);
            
            // ì¤€ë¹„ ìƒíƒœë¡œ ì—°ê²° ë³´ê´€
            preparedConnections.put(transactionId, connection);
            return true;
            
        } catch (Exception e) {
            log.error("íŠ¸ëœì­ì…˜ ì¤€ë¹„ ì‹¤íŒ¨", e);
            return false;
        }
    }
    
    @Override
    public void commit(String transactionId) {
        Connection connection = preparedConnections.remove(transactionId);
        if (connection != null) {
            try {
                connection.commit();
                connection.close();
            } catch (SQLException e) {
                log.error("íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì‹¤íŒ¨", e);
            }
        }
    }
    
    @Override
    public void abort(String transactionId) {
        Connection connection = preparedConnections.remove(transactionId);
        if (connection != null) {
            try {
                connection.rollback();
                connection.close();
            } catch (SQLException e) {
                log.error("íŠ¸ëœì­ì…˜ ë¡¤ë°± ì‹¤íŒ¨", e);
            }
        }
    }
}
```

### 12.3.2 Saga íŒ¨í„´ (ë³´ìƒ íŠ¸ëœì­ì…˜)

```java
// Saga ë§¤ë‹ˆì €
@Service
public class OrderSagaManager {
    
    private final PaymentService paymentService;
    private final InventoryService inventoryService;
    private final ShippingService shippingService;
    
    public void processOrder(OrderCreatedEvent event) {
        SagaTransaction saga = SagaTransaction.builder()
            .transactionId(UUID.randomUUID().toString())
            .build();
        
        try {
            // Step 1: ì¬ê³  ì˜ˆì•½
            saga.addStep(
                () -> inventoryService.reserveItems(event.getOrderId(), event.getItems()),
                () -> inventoryService.releaseItems(event.getOrderId())
            );
            
            // Step 2: ê²°ì œ ì²˜ë¦¬
            saga.addStep(
                () -> paymentService.processPayment(event.getOrderId(), event.getTotalAmount()),
                () -> paymentService.refundPayment(event.getOrderId())
            );
            
            // Step 3: ë°°ì†¡ ì¤€ë¹„
            saga.addStep(
                () -> shippingService.prepareShipment(event.getOrderId()),
                () -> shippingService.cancelShipment(event.getOrderId())
            );
            
            saga.execute();
            
        } catch (SagaExecutionException e) {
            log.error("Saga ì‹¤í–‰ ì‹¤íŒ¨, ë³´ìƒ íŠ¸ëœì­ì…˜ ì‹œì‘", e);
            saga.compensate();
            throw new OrderProcessingException("ì£¼ë¬¸ ì²˜ë¦¬ ì‹¤íŒ¨", e);
        }
    }
}

// Saga íŠ¸ëœì­ì…˜
public class SagaTransaction {
    
    private final String transactionId;
    private final List<SagaStep> steps = new ArrayList<>();
    private final List<SagaStep> executedSteps = new ArrayList<>();
    
    public void addStep(Runnable action, Runnable compensatingAction) {
        steps.add(new SagaStep(action, compensatingAction));
    }
    
    public void execute() {
        for (SagaStep step : steps) {
            try {
                step.getAction().run();
                executedSteps.add(step);
            } catch (Exception e) {
                compensate();
                throw new SagaExecutionException("Saga ë‹¨ê³„ ì‹¤í–‰ ì‹¤íŒ¨", e);
            }
        }
    }
    
    public void compensate() {
        // ì‹¤í–‰ëœ ë‹¨ê³„ë“¤ì„ ì—­ìˆœìœ¼ë¡œ ë³´ìƒ
        Collections.reverse(executedSteps);
        
        for (SagaStep step : executedSteps) {
            try {
                step.getCompensatingAction().run();
            } catch (Exception e) {
                log.error("ë³´ìƒ íŠ¸ëœì­ì…˜ ì‹¤í–‰ ì‹¤íŒ¨", e);
            }
        }
    }
}

public class SagaStep {
    private final Runnable action;
    private final Runnable compensatingAction;
    
    public SagaStep(Runnable action, Runnable compensatingAction) {
        this.action = action;
        this.compensatingAction = compensatingAction;
    }
}
```

---

## 12.4 ìƒ¤ë”©ê³¼ íŒŒí‹°ì…”ë‹

### 12.4.1 ë°ì´í„°ë² ì´ìŠ¤ ìƒ¤ë”©

```java
// ìƒ¤ë”© ì „ëµ ì¸í„°í˜ì´ìŠ¤
public interface ShardingStrategy {
    String selectShard(String key);
    List<String> getAllShards();
}

// í•´ì‹œ ê¸°ë°˜ ìƒ¤ë”©
@Component
public class HashBasedShardingStrategy implements ShardingStrategy {
    
    private final List<String> shards;
    
    public HashBasedShardingStrategy(@Value("${shards}") List<String> shards) {
        this.shards = shards;
    }
    
    @Override
    public String selectShard(String key) {
        int hash = Math.abs(key.hashCode());
        int shardIndex = hash % shards.size();
        return shards.get(shardIndex);
    }
    
    @Override
    public List<String> getAllShards() {
        return new ArrayList<>(shards);
    }
}

// ë²”ìœ„ ê¸°ë°˜ ìƒ¤ë”©
@Component
public class RangeBasedShardingStrategy implements ShardingStrategy {
    
    private final Map<String, ShardRange> shardRanges;
    
    public RangeBasedShardingStrategy() {
        this.shardRanges = Map.of(
            "shard1", new ShardRange("A", "F"),
            "shard2", new ShardRange("G", "M"),
            "shard3", new ShardRange("N", "S"),
            "shard4", new ShardRange("T", "Z")
        );
    }
    
    @Override
    public String selectShard(String key) {
        String firstChar = key.substring(0, 1).toUpperCase();
        
        return shardRanges.entrySet().stream()
            .filter(entry -> entry.getValue().contains(firstChar))
            .map(Map.Entry::getKey)
            .findFirst()
            .orElse(shardRanges.keySet().iterator().next());
    }
}

// ìƒ¤ë“œëœ ë ˆí¬ì§€í† ë¦¬
@Repository
public class ShardedUserRepository {
    
    private final Map<String, DataSource> shardDataSources;
    private final ShardingStrategy shardingStrategy;
    
    public ShardedUserRepository(Map<String, DataSource> shardDataSources,
                                ShardingStrategy shardingStrategy) {
        this.shardDataSources = shardDataSources;
        this.shardingStrategy = shardingStrategy;
    }
    
    public User findById(String userId) {
        String shard = shardingStrategy.selectShard(userId);
        DataSource dataSource = shardDataSources.get(shard);
        
        try (Connection connection = dataSource.getConnection()) {
            PreparedStatement stmt = connection.prepareStatement(
                "SELECT * FROM users WHERE id = ?"
            );
            stmt.setString(1, userId);
            
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return mapResultSetToUser(rs);
            }
            
            return null;
        } catch (SQLException e) {
            throw new DataAccessException("ì‚¬ìš©ì ì¡°íšŒ ì‹¤íŒ¨", e);
        }
    }
    
    public void save(User user) {
        String shard = shardingStrategy.selectShard(user.getId());
        DataSource dataSource = shardDataSources.get(shard);
        
        try (Connection connection = dataSource.getConnection()) {
            PreparedStatement stmt = connection.prepareStatement(
                "INSERT INTO users (id, name, email) VALUES (?, ?, ?) " +
                "ON DUPLICATE KEY UPDATE name = ?, email = ?"
            );
            stmt.setString(1, user.getId());
            stmt.setString(2, user.getName());
            stmt.setString(3, user.getEmail());
            stmt.setString(4, user.getName());
            stmt.setString(5, user.getEmail());
            
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataAccessException("ì‚¬ìš©ì ì €ì¥ ì‹¤íŒ¨", e);
        }
    }
    
    // í¬ë¡œìŠ¤-ìƒ¤ë“œ ì¡°íšŒ
    public List<User> findByEmail(String email) {
        List<CompletableFuture<List<User>>> futures = new ArrayList<>();
        
        for (String shard : shardingStrategy.getAllShards()) {
            CompletableFuture<List<User>> future = CompletableFuture.supplyAsync(() -> {
                DataSource dataSource = shardDataSources.get(shard);
                return queryUsersByEmail(dataSource, email);
            });
            
            futures.add(future);
        }
        
        return futures.stream()
            .map(CompletableFuture::join)
            .flatMap(List::stream)
            .collect(Collectors.toList());
    }
}
```

---

## ğŸ¯ í•µì‹¬ ìš”ì•½

### ë¶„ì‚° ì‹œìŠ¤í…œ íŒ¨í„´ ë¹„êµ

| **íŒ¨í„´/ì´ë¡ ** | **ëª©ì ** | **ì¥ì ** | **ë‹¨ì ** |
|-------------|---------|---------|---------|
| **CAP ì •ë¦¬** | íŠ¸ë ˆì´ë“œì˜¤í”„ ì´í•´ | ëª…í™•í•œ ì„¤ê³„ ë°©í–¥ | ì´ë¡ ì  í•œê³„ |
| **Raft** | ë¶„ì‚° í•©ì˜ | ì´í•´í•˜ê¸° ì‰¬ì›€ | ë¦¬ë” ì˜ì¡´ì„± |
| **2PC** | ë¶„ì‚° íŠ¸ëœì­ì…˜ | ê°•í•œ ì¼ê´€ì„± | ë†’ì€ ì§€ì—°ì‹œê°„ |
| **Saga** | ë¶„ì‚° íŠ¸ëœì­ì…˜ | ë†’ì€ ê°€ìš©ì„± | ë³µì¡í•œ ë³´ìƒ ë¡œì§ |
| **ìƒ¤ë”©** | ìˆ˜í‰ í™•ì¥ | ë†’ì€ ì„±ëŠ¥ | í¬ë¡œìŠ¤-ìƒ¤ë“œ ì¡°íšŒ ë³µì¡ |

### ì„¤ê³„ ê³ ë ¤ì‚¬í•­
1. **ì¼ê´€ì„± vs ê°€ìš©ì„± íŠ¸ë ˆì´ë“œì˜¤í”„**
2. **ë¶„ì‚° íŠ¸ëœì­ì…˜ ë³µì¡ì„± ê´€ë¦¬**
3. **ë°ì´í„° íŒŒí‹°ì…”ë‹ ì „ëµ**
4. **ì¥ì•  ì²˜ë¦¬ ë° ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜**

---

## ğŸ’­ ìƒê°í•´ë³´ê¸°

1. í˜„ì¬ ì‹œìŠ¤í…œì—ì„œ CAP ì •ë¦¬ì˜ ì–´ë–¤ ì¡°í•©ì„ ì„ íƒí•´ì•¼ í• ê¹Œ?
2. ë¶„ì‚° íŠ¸ëœì­ì…˜ì´ í•„ìš”í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì–´ë–»ê²Œ ì‹ë³„í•  ê²ƒì¸ê°€?
3. ìƒ¤ë”© ì „ëµ ì„ íƒ ì‹œ ê³ ë ¤í•´ì•¼ í•  ìš”ì†Œë“¤ì€ ë¬´ì—‡ì¸ê°€?

---

## ğŸ“š ì¶”ê°€ í•™ìŠµ ìë£Œ

### ë„ì„œ
- "Designing Data-Intensive Applications" - Martin Kleppmann
- "Distributed Systems: Concepts and Design" - George Coulouris

### ì˜¨ë¼ì¸ ìë£Œ
- Raft ì‹œê°í™” ë„êµ¬
- CAP ì •ë¦¬ ìƒì„¸ ì„¤ëª… 