---
title: "[Algorithm] C++/Python 백준 20492번 : 세금"
categories: Algorithm
tags:
- Mathematics
- Arithmetic
- Implementation
- Time Complexity O(1)
image: "tmp_wordcloud.png"
date: 2024-10-16
---

선린인터넷고등학교의 한 학생이 프로그래밍 대회에서 거액의 상금을 수상하게 되었다. 그러나 상금의 전부를 수령할 수 있는 것은 아니며, 일부는 세금으로 납부해야 한다. 일반적으로 상금의 22%를 제세공과금으로 납부하지만, 필요 경비를 인정받는 경우 세금 부담이 줄어들 수 있다. 이번 문제에서는 두 가지 경우에 대해 실제로 수령하게 되는 금액을 계산해보자.

문제 : [https://www.acmicpc.net/problem/20492](https://www.acmicpc.net/problem/20492)

## 문제 설명

선린인터넷고등학교의 한 학생은 프로그래밍 대회에 참가하여 큰 상금을 받는 영광을 누리게 되었다. 그러나 상금은 세금을 납부한 후에야 실제로 수령할 수 있다. 일반적으로 대회에서 상금을 받으면 전체 금액의 22%를 제세공과금으로 국가에 납부해야 하며, 나머지 금액을 수령하게 된다.

하지만 세법에서는 상금의 80%를 필요 경비로 인정받을 수 있는 조항이 있다. 이 경우, 전체 상금의 80%는 필요 경비로 처리되어 과세 대상에서 제외되고, 나머지 20%에 대해서만 세금을 부과한다. 이때도 세율은 동일하게 22%이다. 따라서 실제로 납부해야 할 세금은 전체 상금의 20% 중 22%에 해당하는 금액이 된다.

예를 들어, 상금이 10,000,000원이라면, 첫 번째 방법으로는 22%인 2,200,000원을 세금으로 납부하여 7,800,000원을 수령하게 된다. 두 번째 방법으로는 상금의 20%인 2,000,000원에 대해서만 세금을 부과하므로, 2,000,000원의 22%인 440,000원을 세금으로 납부하여 9,560,000원을 수령하게 된다.

입력으로 상금의 총액 N이 주어질 때, 위 두 가지 방법에 따라 학생이 실제로 수령하게 되는 금액을 각각 계산하여 출력하는 프로그램을 작성하시오.

**입력 조건:**

- N은 1,000 이상 10,000,000 이하의 1,000의 배수인 정수이다.

**출력 형식:**

- 첫 번째 방법으로 수령하는 금액과 두 번째 방법으로 수령하는 금액을 공백으로 구분하여 한 줄에 출력한다.

## 접근 방식

이 문제는 간단한 수학 계산 문제로, 주어진 상금에 대해 두 가지 세금 계산 방식을 적용하여 실제 수령액을 계산하면 된다.

첫 번째 경우는 전체 상금의 22%를 세금으로 납부하는 것이다. 따라서 실제 수령액은 전체 상금에서 22%를 뺀 금액이 된다.

두 번째 경우는 상금의 80%를 필요 경비로 인정받는 것이다. 이때 과세 대상은 나머지 20%이며, 이 20%에 대해 22%의 세금을 납부한다. 따라서 실제 수령액은 전체 상금에서 (상금의 20%에 대한 22% 세금)을 뺀 금액이 된다.

두 경우 모두 간단한 산술 연산으로 계산할 수 있으며, 시간 복잡도는 O(1)이다.

## C++ 코드와 설명

```cpp
#include <iostream>
using namespace std;

int main() {
    long long N;
    cin >> N;

    // 첫 번째 경우: 전체 상금의 22%를 세금으로 납부
    long long case1 = N - N * 22 / 100;

    // 두 번째 경우: 상금의 80%를 필요 경비로 인정받고 나머지 20% 중 22%를 세금으로 납부
    long long case2 = N - (N * 20 / 100) * 22 / 100;

    cout << case1 << " " << case2 << endl;

    return 0;
}
```

### 코드 설명

- `long long N;` : 상금의 금액을 저장하기 위해 `long long` 타입의 변수를 선언한다. 상금의 최대값이 10,000,000이므로 `int`로도 충분하지만, 혹시 모를 오버플로를 방지한다.

- `cin >> N;` : 상금의 금액을 입력받는다.

- `long long case1 = N - N * 22 / 100;` : 첫 번째 경우의 실제 수령액을 계산한다. `N * 22 / 100`은 상금의 22%에 해당하는 세금 금액이다.

- `long long case2 = N - (N * 20 / 100) * 22 / 100;` : 두 번째 경우의 실제 수령액을 계산한다. 먼저 상금의 20%에 해당하는 금액을 구하고, 그 금액의 22%를 세금으로 계산한다.

- `cout << case1 << " " << case2 << endl;` : 두 경우의 수령액을 공백으로 구분하여 출력한다.

이 코드는 입력값에 대한 계산을 바로 수행하며, 시간 복잡도는 O(1)이다.

## C++ without library 코드와 설명

```cpp
#include <stdio.h>

int main() {
    long long N;
    scanf("%lld", &N);

    // 첫 번째 경우 계산
    long long case1 = N - N * 22 / 100;

    // 두 번째 경우 계산
    long long case2 = N - (N * 20 / 100) * 22 / 100;

    printf("%lld %lld\n", case1, case2);

    return 0;
}
```

### 코드 설명

- `#include <stdio.h>` : 표준 입출력 함수를 사용하기 위해 `stdio.h`를 포함한다.

- `long long N;` : 상금의 금액을 저장할 변수 선언.

- `scanf("%lld", &N);` : 상금의 금액을 입력받는다.

- `long long case1 = N - N * 22 / 100;` : 첫 번째 경우의 수령액을 계산.

- `long long case2 = N - (N * 20 / 100) * 22 / 100;` : 두 번째 경우의 수령액을 계산.

- `printf("%lld %lld\n", case1, case2);` : 결과를 출력한다.

이 코드 역시 입력에 대한 계산을 즉시 수행하며, 추가적인 라이브러리를 사용하지 않고 `stdio.h`만으로 구현하였다. 시간 복잡도는 O(1)이다.

## Python 코드와 설명

```python
N = int(input())

# 첫 번째 경우 계산
case1 = N - N * 22 // 100

# 두 번째 경우 계산
case2 = N - (N * 20 // 100) * 22 // 100

print(f"{case1} {case2}")
```

### 코드 설명

- `N = int(input())` : 상금의 금액을 입력받아 정수로 변환하여 저장한다.

- `case1 = N - N * 22 // 100` : 첫 번째 경우의 수령액을 계산한다. `//` 연산자는 정수 나눗셈을 수행한다.

- `case2 = N - (N * 20 // 100) * 22 // 100` : 두 번째 경우의 수령액을 계산한다. 먼저 상금의 20%를 구한 후, 그 금액의 22%를 세금으로 계산한다.

- `print(f"{case1} {case2}")` : 두 경우의 수령액을 공백으로 구분하여 출력한다.

Python에서는 큰 수의 계산도 기본적으로 지원하므로 오버플로에 대한 걱정 없이 계산할 수 있다. 시간 복잡도는 역시 O(1)이다.

## 결론

이 문제는 간단한 산술 연산을 통해 세금 계산 방법에 따른 실제 수령액을 구하는 문제이다. 입력값에 대한 연산을 직접 수행하면 되므로 특별한 알고리즘이나 자료 구조가 필요하지 않다. 문제를 해결하면서 세금 계산의 방법과 필요 경비 인정에 따른 세금 절감 효과를 이해할 수 있었다. 추가적인 최적화는 필요 없으며, 오히려 정확한 계산을 위해 자료형과 연산에 주의하는 것이 중요하다.